// Export summary:
  // - 265 nodes
  // - 397 relationships
  // - 8 node types
  // - 4 relationship types
  // Exported on: 2025-06-19T15:58:22.594285

CREATE CONSTRAINT IF NOT EXISTS FOR (n:Folder) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:File) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:Class) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:Method) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:Function) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:Variable) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:Import) REQUIRE n.id IS UNIQUE;
CREATE CONSTRAINT IF NOT EXISTS FOR (n:ExternalLibrary) REQUIRE n.id IS UNIQUE;
CREATE INDEX IF NOT EXISTS FOR (n:Folder) ON (n.name);
CREATE INDEX IF NOT EXISTS FOR (n:File) ON (n.name);
MERGE (n:Folder {id: "folder-_-Lg=="}) ON CREATE SET n.type = "Folder", n.name = ".", n.file_path = ".", n.content_count = 9, n.content_summary = "1 folders, 8 files", n.content_lists = [[{"name": "ast_analyzer.py", "type": "file", "size": 19643, "last_modified": 1750337727.8909485}, {"name": "constants.py", "type": "file", "size": 2178, "last_modified": 1750337578.3481874}, {"name": "exporters.py", "type": "file", "size": 7774, "last_modified": 1750337812.2102845}, {"name": "helpers.py", "type": "file", "size": 14491, "last_modified": 1750337648.4158242}, {"name": "main.py", "type": "file", "size": 7003, "last_modified": 1750337557.2534184}, {"name": "README.md", "type": "file", "size": 7016, "last_modified": 1750337866.2072873}, {"name": "requirements.txt", "type": "file", "size": 408, "last_modified": 1750337827.300709}, {"name": "scanner.py", "type": "file", "size": 6214, "last_modified": 1750337768.4640186}, {"name": "__pycache__", "type": "folder", "size": 0, "last_modified": 1750337890.423089}]] RETURN n;
MERGE (n:File {id: "file-ast_analyzer.py-YXN0X2Fu"}) ON CREATE SET n.type = "File", n.name = "ast_analyzer.py", n.file_path = ".\\ast_analyzer.py", n.file_size = 19195, n.line_count = 449, n.content_lists = ["\"\"\"\nPython AST Analyzer\nAnalyzes Python source code using the built-in ast module\n\"\"\"\nimport ast\nimport os\nfrom constants import NODE_TYPES, REL_TYPES, STANDARD_LIBRARY_MODULES\nfrom helpers import (\n    create_entity_node, create_relationship, get_or_create_file_node,\n    global_context, external_libraries, is_placeholder\n)\n\ndef is_external_library(module_name):\n    \"\"\"Check if a module is an external library (not standard library or relative import)\"\"\"\n    if module_name.startswith('.'):\n        return False  # Relative import\n    \n    base_module = module_name.split('.')[0]\n    return base_module not in STANDARD_LIBRARY_MODULES\n\ndef get_or_create_external_library_node(library_name, graph, config):\n    \"\"\"Get or create an external library node\"\"\"\n    if library_name in external_libraries:\n        return external_libraries[library_name]\n    \n    # Extract the base library name (e.g., 'requests' from 'requests.auth')\n    base_lib_name = library_name.split('.')[0]\n    \n    # Check if we already have the base library\n    if base_lib_name in external_libraries:\n        return external_libraries[base_lib_name]\n    \n    # Create new library node\n    from helpers import create_node\n    node = create_node(NODE_TYPES['EXTERNAL_LIBRARY'], base_lib_name, None, {\n        'is_external': True,\n        'original_import': library_name\n    })\n    \n    graph['nodes'].append(node)\n    external_libraries[base_lib_name] = node\n    return node\n\nclass PythonASTVisitor(ast.NodeVisitor):\n    \"\"\"AST visitor for analyzing Python code\"\"\"\n    \n    def __init__(self, file_path, source_code, graph, config):\n        self.file_path = file_path\n        self.source_code = source_code\n        self.graph = graph\n        self.config = config\n        self.file_node = get_or_create_file_node(file_path, graph, config)\n        \n        # Scope tracking\n        self.scope_tracker = {\n            'current_class': None,\n            'current_method': None,\n            'declared_variables': {},\n            'imported_modules': {}\n        }\n        \n        # Reset global context for this file\n        global_context['current_class_context'] = None\n        global_context['current_method_context'] = None\n        global_context['current_scope_context'] = None\n        global_context['current_class_node'] = None\n        global_context['current_method_node'] = None\n    \n    def get_location_info(self, node):\n        \"\"\"Extract location information from an AST node\"\"\"\n        return {\n            'lineno': getattr(node, 'lineno', 0),\n            'col_offset': getattr(node, 'col_offset', 0),\n            'end_lineno': getattr(node, 'end_lineno', 0),\n            'end_col_offset': getattr(node, 'end_col_offset', 0)\n        }\n    \n    def visit_Import(self, node):\n        \"\"\"Handle import statements: import module\"\"\"\n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            \n            if self.config.get('track_external_libraries') and is_external_library(import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported module\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    import_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported module\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)\n    \n    def visit_ImportFrom(self, node):\n        \"\"\"Handle from ... import ... statements\"\"\"\n        module = node.module or ''\n        \n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            full_name = f\"{module}.{import_name}\" if module else import_name\n            \n            if self.config.get('track_external_libraries') and is_external_library(module or import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(module or import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported name\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    full_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'from_module': module, 'import_name': import_name, 'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported name\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)\n    \n    def visit_ClassDef(self, node):\n        \"\"\"Handle class definitions\"\"\"\n        class_name = node.name\n        class_node = create_entity_node(\n            NODE_TYPES['CLASS'],\n            class_name,\n            self.file_path,\n            self.get_location_info(node),\n            {\n                'is_async': False,\n                'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n            },\n            self.source_code,\n            self.graph,\n            self.config\n        )\n        \n        if not is_placeholder(class_node):\n            # Update global context\n            global_context['current_class_context'] = class_name\n            \n            # Track for nested methods\n            previous_class = self.scope_tracker['current_class']\n            self.scope_tracker['current_class'] = class_node['id']\n            \n            # Handle class inheritance\n            for base in node.bases:\n                if isinstance(base, ast.Name):\n                    base_name = base.id\n                    if base_name in self.scope_tracker['imported_modules']:\n                        relationship = create_relationship(\n                            class_node['id'],\n                            self.scope_tracker['imported_modules'][base_name],\n                            REL_TYPES['EXTENDS']\n                        )\n                        self.graph['relationships'].append(relationship)\n            \n            # Visit child nodes\n            self.generic_visit(node)\n            \n            # Restore previous context\n            self.scope_tracker['current_class'] = previous_class\n            global_context['current_class_context'] = None\n    \n    def visit_FunctionDef(self, node):\n        \"\"\"Handle function definitions\"\"\"\n        func_name = node.name\n        \n        # Determine if this is a method or a function\n        if self.scope_tracker['current_class']:\n            # This is a method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                # Update method context\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\"{global_context['current_class_context']}.{func_name}\"\n                \n                # Create relationship with containing class\n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                # Track current method for variable scope\n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore previous context\n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is a function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                # Update context\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                # Add to scope\n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore context\n                global_context['current_scope_context'] = None\n    \n    def visit_AsyncFunctionDef(self, node):\n        \"\"\"Handle async function definitions\"\"\"\n        # Similar to visit_FunctionDef but mark as async\n        func_name = node.name\n        \n        if self.scope_tracker['current_class']:\n            # This is an async method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\"{global_context['current_class_context']}.{func_name}\"\n                \n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                self.generic_visit(node)\n                \n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is an async function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                self.generic_visit(node)\n                \n                global_context['current_scope_context'] = None\n    \n    def visit_Assign(self, node):\n        \"\"\"Handle variable assignments\"\"\"\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                var_name = target.id\n                var_node = create_entity_node(\n                    NODE_TYPES['VARIABLE'],\n                    var_name,\n                    self.file_path,\n                    self.get_location_info(target),\n                    {},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(var_node):\n                    # Track in current scope\n                    self.scope_tracker['declared_variables'][var_name] = var_node['id']\n                    \n                    # Handle variable initialization references\n                    if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                        callee_name = node.value.func.id\n                        if callee_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][callee_name],\n                                REL_TYPES['CALLS']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    elif isinstance(node.value, ast.Name):\n                        init_name = node.value.id\n                        if init_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][init_name],\n                                REL_TYPES['REFERENCES']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    \n                    # Connect to parent scope\n                    if self.scope_tracker['current_method']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_method'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n                    elif self.scope_tracker['current_class']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_class'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)\n    \n    def visit_Call(self, node):\n        \"\"\"Handle function calls\"\"\"\n        if isinstance(node.func, ast.Name):\n            callee_name = node.func.id\n            \n            # Regular function calls\n            if callee_name in self.scope_tracker['declared_variables']:\n                # Create a relationship from current scope to the called function\n                source_id = None\n                if self.scope_tracker['current_method']:\n                    source_id = self.scope_tracker['current_method']\n                elif self.scope_tracker['current_class']:\n                    source_id = self.scope_tracker['current_class']\n                else:\n                    source_id = self.file_node['id']\n                \n                relationship = create_relationship(\n                    source_id,\n                    self.scope_tracker['declared_variables'][callee_name],\n                    REL_TYPES['CALLS']\n                )\n                self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)\n\ndef analyze_file(file_path, graph, config):\n    \"\"\"Analyze a Python file and extract its structure\"\"\"\n    print(f\"Analyzing file: {file_path}\")\n    \n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            source_code = f.read()\n        \n        # Parse the AST\n        tree = ast.parse(source_code, filename=file_path)\n        \n        # Create and run the visitor\n        visitor = PythonASTVisitor(file_path, source_code, graph, config)\n        visitor.visit(tree)\n        \n    except SyntaxError as e:\n        print(f\"Syntax error in {file_path}: {e}\")\n    except Exception as e:\n        print(f\"Error analyzing file {file_path}: {e}\") "] RETURN n;
MERGE (n:ExternalLibrary {id: "lib-ast"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "ast", n.is_external = true, n.original_import = "ast" RETURN n;
MERGE (n:Import {id: "import-os"}) ON CREATE SET n.type = "Import", n.name = "os", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 6, \"column\": 0, \"end_line\": 6, \"end_column\": 9}", n.as_name = "os", n.code_scope = "import os" RETURN n;
MERGE (n:ExternalLibrary {id: "lib-constants"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "constants", n.is_external = true, n.original_import = "constants" RETURN n;
MERGE (n:ExternalLibrary {id: "lib-helpers"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "helpers", n.is_external = true, n.original_import = "helpers" RETURN n;
MERGE (n:Function {id: "function-is_external_library-ast_analyzer-L0"}) ON CREATE SET n.type = "Function", n.name = "is_external_library", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 13, \"column\": 0, \"end_line\": 19, \"end_column\": 54}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def is_external_library(module_name):\n    \\\"\\\"\\\"Check if a module is an external library (not standard library or relative import)\\\"\\\"\\\"\n    if module_name.startswith('.'):\n        return False  # Relative import\n    \n    base_module = module_name.split('.')[0]\n    return base_module not in STANDARD_LIBRARY_MODULES" RETURN n;
MERGE (n:Variable {id: "variable-base_module-is_external_library-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "base_module", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 18, \"column\": 4, \"end_line\": 18, \"end_column\": 15}", n.code_scope = "base_module" RETURN n;
MERGE (n:Function {id: "function-get_or_create_external_library_node-ast_analyzer-L0"}) ON CREATE SET n.type = "Function", n.name = "get_or_create_external_library_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 21, \"column\": 0, \"end_line\": 42, \"end_column\": 15}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def get_or_create_external_library_node(library_name, graph, config):\n    \\\"\\\"\\\"Get or create an external library node\\\"\\\"\\\"\n    if library_name in external_libraries:\n        return external_libraries[library_name]\n    \n    # Extract the base library name (e.g., 'requests' from 'requests.auth')\n    base_lib_name = library_name.split('.')[0]\n    \n    # Check if we already have the base library\n    if base_lib_name in external_libraries:\n        return external_libraries[base_lib_name]\n    \n    # Create new library node\n    from helpers import create_node\n    node = create_node(NODE_TYPES['EXTERNAL_LIBRARY'], base_lib_name, None, {\n        'is_external': True,\n        'original_import': library_name\n    })\n    \n    graph['nodes'].append(node)\n    external_libraries[base_lib_name] = node\n    return node" RETURN n;
MERGE (n:Variable {id: "variable-base_lib_name-get_or_create_external_library_node-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "base_lib_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 27, \"column\": 4, \"end_line\": 27, \"end_column\": 17}", n.code_scope = "base_lib_name" RETURN n;
MERGE (n:Variable {id: "variable-node-get_or_create_external_library_node-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 35, \"column\": 4, \"end_line\": 35, \"end_column\": 8}", n.code_scope = "node" RETURN n;
MERGE (n:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Class", n.name = "PythonASTVisitor", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 44, \"column\": 0, \"end_line\": 429, \"end_column\": 32}", n.is_async = false, n.decorators = [], n.code_scope = "class PythonASTVisitor(ast.NodeVisitor):\n    \\\"\\\"\\\"AST visitor for analyzing Python code\\\"\\\"\\\"\n    \n    def __init__(self, file_path, source_code, graph, config):\n        self.file_path = file_path\n        self.source_code = source_code\n        self.graph = graph\n        self.config = config\n        self.file_node = get_or_create_file_node(file_path, graph, config)\n        \n        # Scope tracking\n        self.scope_tracker = {\n            'current_class': None,\n            'current_method': None,\n            'declared_variables': {},\n            'imported_modules': {}\n        }\n        \n        # Reset global context for this file\n        global_context['current_class_context'] = None\n        global_context['current_method_context'] = None\n        global_context['current_scope_context'] = None\n        global_context['current_class_node'] = None\n        global_context['current_method_node'] = None\n    \n    def get_location_info(self, node):\n        \\\"\\\"\\\"Extract location information from an AST node\\\"\\\"\\\"\n        return {\n            'lineno': getattr(node, 'lineno', 0),\n            'col_offset': getattr(node, 'col_offset', 0),\n            'end_lineno': getattr(node, 'end_lineno', 0),\n            'end_col_offset': getattr(node, 'end_col_offset', 0)\n        }\n    \n    def visit_Import(self, node):\n        \\\"\\\"\\\"Handle import statements: import module\\\"\\\"\\\"\n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            \n            if self.config.get('track_external_libraries') and is_external_library(import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported module\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    import_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported module\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)\n    \n    def visit_ImportFrom(self, node):\n        \\\"\\\"\\\"Handle from ... import ... statements\\\"\\\"\\\"\n        module = node.module or ''\n        \n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            full_name = f\\\"{module}.{import_name}\\\" if module else import_name\n            \n            if self.config.get('track_external_libraries') and is_external_library(module or import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(module or import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported name\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    full_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'from_module': module, 'import_name': import_name, 'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported name\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)\n    \n    def visit_ClassDef(self, node):\n        \\\"\\\"\\\"Handle class definitions\\\"\\\"\\\"\n        class_name = node.name\n        class_node = create_entity_node(\n            NODE_TYPES['CLASS'],\n            class_name,\n            self.file_path,\n            self.get_location_info(node),\n            {\n                'is_async': False,\n                'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n            },\n            self.source_code,\n            self.graph,\n            self.config\n        )\n        \n        if not is_placeholder(class_node):\n            # Update global context\n            global_context['current_class_context'] = class_name\n            \n            # Track for nested methods\n            previous_class = self.scope_tracker['current_class']\n            self.scope_tracker['current_class'] = class_node['id']\n            \n            # Handle class inheritance\n            for base in node.bases:\n                if isinstance(base, ast.Name):\n                    base_name = base.id\n                    if base_name in self.scope_tracker['imported_modules']:\n                        relationship = create_relationship(\n                            class_node['id'],\n                            self.scope_tracker['imported_modules'][base_name],\n                            REL_TYPES['EXTENDS']\n                        )\n                        self.graph['relationships'].append(relationship)\n            \n            # Visit child nodes\n            self.generic_visit(node)\n            \n            # Restore previous context\n            self.scope_tracker['current_class'] = previous_class\n            global_context['current_class_context'] = None\n    \n    def visit_FunctionDef(self, node):\n        \\\"\\\"\\\"Handle function definitions\\\"\\\"\\\"\n        func_name = node.name\n        \n        # Determine if this is a method or a function\n        if self.scope_tracker['current_class']:\n            # This is a method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                # Update method context\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\\\"{global_context['current_class_context']}.{func_name}\\\"\n                \n                # Create relationship with containing class\n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                # Track current method for variable scope\n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore previous context\n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is a function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                # Update context\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                # Add to scope\n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore context\n                global_context['current_scope_context'] = None\n    \n    def visit_AsyncFunctionDef(self, node):\n        \\\"\\\"\\\"Handle async function definitions\\\"\\\"\\\"\n        # Similar to visit_FunctionDef but mark as async\n        func_name = node.name\n        \n        if self.scope_tracker['current_class']:\n            # This is an async method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\\\"{global_context['current_class_context']}.{func_name}\\\"\n                \n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                self.generic_visit(node)\n                \n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is an async function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                self.generic_visit(node)\n                \n                global_context['current_scope_context'] = None\n    \n    def visit_Assign(self, node):\n        \\\"\\\"\\\"Handle variable assignments\\\"\\\"\\\"\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                var_name = target.id\n                var_node = create_entity_node(\n                    NODE_TYPES['VARIABLE'],\n                    var_name,\n                    self.file_path,\n                    self.get_location_info(target),\n                    {},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(var_node):\n                    # Track in current scope\n                    self.scope_tracker['declared_variables'][var_name] = var_node['id']\n                    \n                    # Handle variable initialization references\n                    if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                        callee_name = node.value.func.id\n                        if callee_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][callee_name],\n                                REL_TYPES['CALLS']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    elif isinstance(node.value, ast.Name):\n                        init_name = node.value.id\n                        if init_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][init_name],\n                                REL_TYPES['REFERENCES']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    \n                    # Connect to parent scope\n                    if self.scope_tracker['current_method']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_method'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n                    elif self.scope_tracker['current_class']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_class'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)\n    \n    def visit_Call(self, node):\n        \\\"\\\"\\\"Handle function calls\\\"\\\"\\\"\n        if isinstance(node.func, ast.Name):\n            callee_name = node.func.id\n            \n            # Regular function calls\n            if callee_name in self.scope_tracker['declared_variables']:\n                # Create a relationship from current scope to the called function\n                source_id = None\n                if self.scope_tracker['current_method']:\n                    source_id = self.scope_tracker['current_method']\n                elif self.scope_tracker['current_class']:\n                    source_id = self.scope_tracker['current_class']\n                else:\n                    source_id = self.file_node['id']\n                \n                relationship = create_relationship(\n                    source_id,\n                    self.scope_tracker['declared_variables'][callee_name],\n                    REL_TYPES['CALLS']\n                )\n                self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)", n.content_lists = ["class PythonASTVisitor(ast.NodeVisitor):\n    \"\"\"AST visitor for analyzing Python code\"\"\"\n    \n    def __init__(self, file_path, source_code, graph, config):\n        self.file_path = file_path\n        self.source_code = source_code\n        self.graph = graph\n        self.config = config\n        self.file_node = get_or_create_file_node(file_path, graph, config)\n        \n        # Scope tracking\n        self.scope_tracker = {\n            'current_class': None,\n            'current_method': None,\n            'declared_variables': {},\n            'imported_modules': {}\n        }\n        \n        # Reset global context for this file\n        global_context['current_class_context'] = None\n        global_context['current_method_context'] = None\n        global_context['current_scope_context'] = None\n        global_context['current_class_node'] = None\n        global_context['current_method_node'] = None\n    \n    def get_location_info(self, node):\n        \"\"\"Extract location information from an AST node\"\"\"\n        return {\n            'lineno': getattr(node, 'lineno', 0),\n            'col_offset': getattr(node, 'col_offset', 0),\n            'end_lineno': getattr(node, 'end_lineno', 0),\n            'end_col_offset': getattr(node, 'end_col_offset', 0)\n        }\n    \n    def visit_Import(self, node):\n        \"\"\"Handle import statements: import module\"\"\"\n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            \n            if self.config.get('track_external_libraries') and is_external_library(import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported module\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    import_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported module\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)\n    \n    def visit_ImportFrom(self, node):\n        \"\"\"Handle from ... import ... statements\"\"\"\n        module = node.module or ''\n        \n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            full_name = f\"{module}.{import_name}\" if module else import_name\n            \n            if self.config.get('track_external_libraries') and is_external_library(module or import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(module or import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported name\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    full_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'from_module': module, 'import_name': import_name, 'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported name\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)\n    \n    def visit_ClassDef(self, node):\n        \"\"\"Handle class definitions\"\"\"\n        class_name = node.name\n        class_node = create_entity_node(\n            NODE_TYPES['CLASS'],\n            class_name,\n            self.file_path,\n            self.get_location_info(node),\n            {\n                'is_async': False,\n                'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n            },\n            self.source_code,\n            self.graph,\n            self.config\n        )\n        \n        if not is_placeholder(class_node):\n            # Update global context\n            global_context['current_class_context'] = class_name\n            \n            # Track for nested methods\n            previous_class = self.scope_tracker['current_class']\n            self.scope_tracker['current_class'] = class_node['id']\n            \n            # Handle class inheritance\n            for base in node.bases:\n                if isinstance(base, ast.Name):\n                    base_name = base.id\n                    if base_name in self.scope_tracker['imported_modules']:\n                        relationship = create_relationship(\n                            class_node['id'],\n                            self.scope_tracker['imported_modules'][base_name],\n                            REL_TYPES['EXTENDS']\n                        )\n                        self.graph['relationships'].append(relationship)\n            \n            # Visit child nodes\n            self.generic_visit(node)\n            \n            # Restore previous context\n            self.scope_tracker['current_class'] = previous_class\n            global_context['current_class_context'] = None\n    \n    def visit_FunctionDef(self, node):\n        \"\"\"Handle function definitions\"\"\"\n        func_name = node.name\n        \n        # Determine if this is a method or a function\n        if self.scope_tracker['current_class']:\n            # This is a method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                # Update method context\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\"{global_context['current_class_context']}.{func_name}\"\n                \n                # Create relationship with containing class\n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                # Track current method for variable scope\n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore previous context\n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is a function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                # Update context\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                # Add to scope\n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore context\n                global_context['current_scope_context'] = None\n    \n    def visit_AsyncFunctionDef(self, node):\n        \"\"\"Handle async function definitions\"\"\"\n        # Similar to visit_FunctionDef but mark as async\n        func_name = node.name\n        \n        if self.scope_tracker['current_class']:\n            # This is an async method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\"{global_context['current_class_context']}.{func_name}\"\n                \n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                self.generic_visit(node)\n                \n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is an async function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                self.generic_visit(node)\n                \n                global_context['current_scope_context'] = None\n    \n    def visit_Assign(self, node):\n        \"\"\"Handle variable assignments\"\"\"\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                var_name = target.id\n                var_node = create_entity_node(\n                    NODE_TYPES['VARIABLE'],\n                    var_name,\n                    self.file_path,\n                    self.get_location_info(target),\n                    {},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(var_node):\n                    # Track in current scope\n                    self.scope_tracker['declared_variables'][var_name] = var_node['id']\n                    \n                    # Handle variable initialization references\n                    if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                        callee_name = node.value.func.id\n                        if callee_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][callee_name],\n                                REL_TYPES['CALLS']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    elif isinstance(node.value, ast.Name):\n                        init_name = node.value.id\n                        if init_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][init_name],\n                                REL_TYPES['REFERENCES']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    \n                    # Connect to parent scope\n                    if self.scope_tracker['current_method']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_method'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n                    elif self.scope_tracker['current_class']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_class'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)\n    \n    def visit_Call(self, node):\n        \"\"\"Handle function calls\"\"\"\n        if isinstance(node.func, ast.Name):\n            callee_name = node.func.id\n            \n            # Regular function calls\n            if callee_name in self.scope_tracker['declared_variables']:\n                # Create a relationship from current scope to the called function\n                source_id = None\n                if self.scope_tracker['current_method']:\n                    source_id = self.scope_tracker['current_method']\n                elif self.scope_tracker['current_class']:\n                    source_id = self.scope_tracker['current_class']\n                else:\n                    source_id = self.file_node['id']\n                \n                relationship = create_relationship(\n                    source_id,\n                    self.scope_tracker['declared_variables'][callee_name],\n                    REL_TYPES['CALLS']\n                )\n                self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)"] RETURN n;
MERGE (n:Method {id: "method-__init__-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "__init__", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 47, \"column\": 4, \"end_line\": 67, \"end_column\": 52}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def __init__(self, file_path, source_code, graph, config):\n        self.file_path = file_path\n        self.source_code = source_code\n        self.graph = graph\n        self.config = config\n        self.file_node = get_or_create_file_node(file_path, graph, config)\n        \n        # Scope tracking\n        self.scope_tracker = {\n            'current_class': None,\n            'current_method': None,\n            'declared_variables': {},\n            'imported_modules': {}\n        }\n        \n        # Reset global context for this file\n        global_context['current_class_context'] = None\n        global_context['current_method_context'] = None\n        global_context['current_scope_context'] = None\n        global_context['current_class_node'] = None\n        global_context['current_method_node'] = None", n.content_lists = ["def __init__(self, file_path, source_code, graph, config):\n        self.file_path = file_path\n        self.source_code = source_code\n        self.graph = graph\n        self.config = config\n        self.file_node = get_or_create_file_node(file_path, graph, config)\n        \n        # Scope tracking\n        self.scope_tracker = {\n            'current_class': None,\n            'current_method': None,\n            'declared_variables': {},\n            'imported_modules': {}\n        }\n        \n        # Reset global context for this file\n        global_context['current_class_context'] = None\n        global_context['current_method_context'] = None\n        global_context['current_scope_context'] = None\n        global_context['current_class_node'] = None\n        global_context['current_method_node'] = None"] RETURN n;
MERGE (n:Method {id: "method-get_location_info-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "get_location_info", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 69, \"column\": 4, \"end_line\": 76, \"end_column\": 9}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def get_location_info(self, node):\n        \\\"\\\"\\\"Extract location information from an AST node\\\"\\\"\\\"\n        return {\n            'lineno': getattr(node, 'lineno', 0),\n            'col_offset': getattr(node, 'col_offset', 0),\n            'end_lineno': getattr(node, 'end_lineno', 0),\n            'end_col_offset': getattr(node, 'end_col_offset', 0)\n        }", n.content_lists = ["def get_location_info(self, node):\n        \"\"\"Extract location information from an AST node\"\"\"\n        return {\n            'lineno': getattr(node, 'lineno', 0),\n            'col_offset': getattr(node, 'col_offset', 0),\n            'end_lineno': getattr(node, 'end_lineno', 0),\n            'end_col_offset': getattr(node, 'end_col_offset', 0)\n        }"] RETURN n;
MERGE (n:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_Import", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 78, \"column\": 4, \"end_line\": 112, \"end_column\": 32}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_Import(self, node):\n        \\\"\\\"\\\"Handle import statements: import module\\\"\\\"\\\"\n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            \n            if self.config.get('track_external_libraries') and is_external_library(import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported module\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    import_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported module\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)", n.content_lists = ["def visit_Import(self, node):\n        \"\"\"Handle import statements: import module\"\"\"\n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            \n            if self.config.get('track_external_libraries') and is_external_library(import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported module\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    import_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported module\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)"] RETURN n;
MERGE (n:Variable {id: "variable-import_name-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "import_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 81, \"column\": 12, \"end_line\": 81, \"end_column\": 23}", n.code_scope = "import_name" RETURN n;
MERGE (n:Variable {id: "variable-as_name-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "as_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 82, \"column\": 12, \"end_line\": 82, \"end_column\": 19}", n.code_scope = "as_name" RETURN n;
MERGE (n:Variable {id: "variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "library_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 86, \"column\": 16, \"end_line\": 86, \"end_column\": 28}", n.code_scope = "library_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 87, \"column\": 16, \"end_line\": 87, \"end_column\": 28}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-import_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "import_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 94, \"column\": 16, \"end_line\": 94, \"end_column\": 27}", n.code_scope = "import_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 106, \"column\": 20, \"end_line\": 106, \"end_column\": 32}", n.code_scope = "relationship" RETURN n;
MERGE (n:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_ImportFrom", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 114, \"column\": 4, \"end_line\": 151, \"end_column\": 32}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_ImportFrom(self, node):\n        \\\"\\\"\\\"Handle from ... import ... statements\\\"\\\"\\\"\n        module = node.module or ''\n        \n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            full_name = f\\\"{module}.{import_name}\\\" if module else import_name\n            \n            if self.config.get('track_external_libraries') and is_external_library(module or import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(module or import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported name\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    full_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'from_module': module, 'import_name': import_name, 'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported name\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)", n.content_lists = ["def visit_ImportFrom(self, node):\n        \"\"\"Handle from ... import ... statements\"\"\"\n        module = node.module or ''\n        \n        for alias in node.names:\n            import_name = alias.name\n            as_name = alias.asname or alias.name\n            full_name = f\"{module}.{import_name}\" if module else import_name\n            \n            if self.config.get('track_external_libraries') and is_external_library(module or import_name):\n                # Handle external library import\n                library_node = get_or_create_external_library_node(module or import_name, self.graph, self.config)\n                relationship = create_relationship(self.file_node['id'], library_node['id'], REL_TYPES['IMPORTS'])\n                self.graph['relationships'].append(relationship)\n                \n                # Track imported name\n                self.scope_tracker['imported_modules'][as_name] = library_node['id']\n            else:\n                # Handle internal/standard library import\n                import_node = create_entity_node(\n                    NODE_TYPES['IMPORT'],\n                    full_name,\n                    self.file_path,\n                    self.get_location_info(node),\n                    {'from_module': module, 'import_name': import_name, 'as_name': as_name},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(import_node):\n                    relationship = create_relationship(self.file_node['id'], import_node['id'], REL_TYPES['IMPORTS'])\n                    self.graph['relationships'].append(relationship)\n                    \n                    # Track imported name\n                    self.scope_tracker['imported_modules'][as_name] = import_node['id']\n        \n        self.generic_visit(node)"] RETURN n;
MERGE (n:Variable {id: "variable-module-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "module", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 116, \"column\": 8, \"end_line\": 116, \"end_column\": 14}", n.code_scope = "module" RETURN n;
MERGE (n:Variable {id: "variable-import_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "import_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 119, \"column\": 12, \"end_line\": 119, \"end_column\": 23}", n.code_scope = "import_name" RETURN n;
MERGE (n:Variable {id: "variable-as_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "as_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 120, \"column\": 12, \"end_line\": 120, \"end_column\": 19}", n.code_scope = "as_name" RETURN n;
MERGE (n:Variable {id: "variable-full_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "full_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 121, \"column\": 12, \"end_line\": 121, \"end_column\": 21}", n.code_scope = "full_name" RETURN n;
MERGE (n:Variable {id: "variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "library_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 125, \"column\": 16, \"end_line\": 125, \"end_column\": 28}", n.code_scope = "library_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 126, \"column\": 16, \"end_line\": 126, \"end_column\": 28}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-import_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "import_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 133, \"column\": 16, \"end_line\": 133, \"end_column\": 27}", n.code_scope = "import_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 145, \"column\": 20, \"end_line\": 145, \"end_column\": 32}", n.code_scope = "relationship" RETURN n;
MERGE (n:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_ClassDef", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 153, \"column\": 4, \"end_line\": 195, \"end_column\": 58}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_ClassDef(self, node):\n        \\\"\\\"\\\"Handle class definitions\\\"\\\"\\\"\n        class_name = node.name\n        class_node = create_entity_node(\n            NODE_TYPES['CLASS'],\n            class_name,\n            self.file_path,\n            self.get_location_info(node),\n            {\n                'is_async': False,\n                'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n            },\n            self.source_code,\n            self.graph,\n            self.config\n        )\n        \n        if not is_placeholder(class_node):\n            # Update global context\n            global_context['current_class_context'] = class_name\n            \n            # Track for nested methods\n            previous_class = self.scope_tracker['current_class']\n            self.scope_tracker['current_class'] = class_node['id']\n            \n            # Handle class inheritance\n            for base in node.bases:\n                if isinstance(base, ast.Name):\n                    base_name = base.id\n                    if base_name in self.scope_tracker['imported_modules']:\n                        relationship = create_relationship(\n                            class_node['id'],\n                            self.scope_tracker['imported_modules'][base_name],\n                            REL_TYPES['EXTENDS']\n                        )\n                        self.graph['relationships'].append(relationship)\n            \n            # Visit child nodes\n            self.generic_visit(node)\n            \n            # Restore previous context\n            self.scope_tracker['current_class'] = previous_class\n            global_context['current_class_context'] = None", n.content_lists = ["def visit_ClassDef(self, node):\n        \"\"\"Handle class definitions\"\"\"\n        class_name = node.name\n        class_node = create_entity_node(\n            NODE_TYPES['CLASS'],\n            class_name,\n            self.file_path,\n            self.get_location_info(node),\n            {\n                'is_async': False,\n                'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n            },\n            self.source_code,\n            self.graph,\n            self.config\n        )\n        \n        if not is_placeholder(class_node):\n            # Update global context\n            global_context['current_class_context'] = class_name\n            \n            # Track for nested methods\n            previous_class = self.scope_tracker['current_class']\n            self.scope_tracker['current_class'] = class_node['id']\n            \n            # Handle class inheritance\n            for base in node.bases:\n                if isinstance(base, ast.Name):\n                    base_name = base.id\n                    if base_name in self.scope_tracker['imported_modules']:\n                        relationship = create_relationship(\n                            class_node['id'],\n                            self.scope_tracker['imported_modules'][base_name],\n                            REL_TYPES['EXTENDS']\n                        )\n                        self.graph['relationships'].append(relationship)\n            \n            # Visit child nodes\n            self.generic_visit(node)\n            \n            # Restore previous context\n            self.scope_tracker['current_class'] = previous_class\n            global_context['current_class_context'] = None"] RETURN n;
MERGE (n:Variable {id: "variable-class_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "class_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 155, \"column\": 8, \"end_line\": 155, \"end_column\": 18}", n.code_scope = "class_name" RETURN n;
MERGE (n:Variable {id: "variable-class_node-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "class_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 156, \"column\": 8, \"end_line\": 156, \"end_column\": 18}", n.code_scope = "class_node" RETURN n;
MERGE (n:Variable {id: "variable-previous_class-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "previous_class", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 175, \"column\": 12, \"end_line\": 175, \"end_column\": 26}", n.code_scope = "previous_class" RETURN n;
MERGE (n:Variable {id: "variable-base_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "base_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 181, \"column\": 20, \"end_line\": 181, \"end_column\": 29}", n.code_scope = "base_name" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 183, \"column\": 24, \"end_line\": 183, \"end_column\": 36}", n.code_scope = "relationship" RETURN n;
MERGE (n:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_FunctionDef", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 197, \"column\": 4, \"end_line\": 275, \"end_column\": 62}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_FunctionDef(self, node):\n        \\\"\\\"\\\"Handle function definitions\\\"\\\"\\\"\n        func_name = node.name\n        \n        # Determine if this is a method or a function\n        if self.scope_tracker['current_class']:\n            # This is a method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                # Update method context\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\\\"{global_context['current_class_context']}.{func_name}\\\"\n                \n                # Create relationship with containing class\n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                # Track current method for variable scope\n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore previous context\n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is a function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                # Update context\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                # Add to scope\n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore context\n                global_context['current_scope_context'] = None", n.content_lists = ["def visit_FunctionDef(self, node):\n        \"\"\"Handle function definitions\"\"\"\n        func_name = node.name\n        \n        # Determine if this is a method or a function\n        if self.scope_tracker['current_class']:\n            # This is a method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                # Update method context\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\"{global_context['current_class_context']}.{func_name}\"\n                \n                # Create relationship with containing class\n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                # Track current method for variable scope\n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore previous context\n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is a function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': False,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                # Update context\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                # Add to scope\n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                # Visit child nodes\n                self.generic_visit(node)\n                \n                # Restore context\n                global_context['current_scope_context'] = None"] RETURN n;
MERGE (n:Variable {id: "variable-func_name-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "func_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 199, \"column\": 8, \"end_line\": 199, \"end_column\": 17}", n.code_scope = "func_name" RETURN n;
MERGE (n:Variable {id: "variable-method_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "method_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 204, \"column\": 12, \"end_line\": 204, \"end_column\": 23}", n.code_scope = "method_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 227, \"column\": 16, \"end_line\": 227, \"end_column\": 28}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-previous_method-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "previous_method", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 235, \"column\": 16, \"end_line\": 235, \"end_column\": 31}", n.code_scope = "previous_method" RETURN n;
MERGE (n:Variable {id: "variable-func_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "func_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 247, \"column\": 12, \"end_line\": 247, \"end_column\": 21}", n.code_scope = "func_node" RETURN n;
MERGE (n:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_AsyncFunctionDef", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 277, \"column\": 4, \"end_line\": 346, \"end_column\": 62}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_AsyncFunctionDef(self, node):\n        \\\"\\\"\\\"Handle async function definitions\\\"\\\"\\\"\n        # Similar to visit_FunctionDef but mark as async\n        func_name = node.name\n        \n        if self.scope_tracker['current_class']:\n            # This is an async method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\\\"{global_context['current_class_context']}.{func_name}\\\"\n                \n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                self.generic_visit(node)\n                \n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is an async function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                self.generic_visit(node)\n                \n                global_context['current_scope_context'] = None", n.content_lists = ["def visit_AsyncFunctionDef(self, node):\n        \"\"\"Handle async function definitions\"\"\"\n        # Similar to visit_FunctionDef but mark as async\n        func_name = node.name\n        \n        if self.scope_tracker['current_class']:\n            # This is an async method\n            method_node = create_entity_node(\n                NODE_TYPES['METHOD'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'parent_class': global_context['current_class_context'],\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(method_node):\n                global_context['current_method_context'] = func_name\n                global_context['current_scope_context'] = f\"{global_context['current_class_context']}.{func_name}\"\n                \n                relationship = create_relationship(\n                    self.scope_tracker['current_class'],\n                    method_node['id'],\n                    REL_TYPES['CONTAINS']\n                )\n                self.graph['relationships'].append(relationship)\n                \n                previous_method = self.scope_tracker['current_method']\n                self.scope_tracker['current_method'] = method_node['id']\n                \n                self.generic_visit(node)\n                \n                self.scope_tracker['current_method'] = previous_method\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = global_context['current_class_context']\n        else:\n            # This is an async function\n            func_node = create_entity_node(\n                NODE_TYPES['FUNCTION'],\n                func_name,\n                self.file_path,\n                self.get_location_info(node),\n                {\n                    'is_async': True,\n                    'is_generator': any(isinstance(n, ast.Yield) or isinstance(n, ast.YieldFrom) \n                                     for n in ast.walk(node)),\n                    'decorators': [d.id if isinstance(d, ast.Name) else str(d) for d in node.decorator_list]\n                },\n                self.source_code,\n                self.graph,\n                self.config\n            )\n            \n            if not is_placeholder(func_node):\n                global_context['current_method_context'] = None\n                global_context['current_scope_context'] = func_name\n                \n                self.scope_tracker['declared_variables'][func_name] = func_node['id']\n                \n                self.generic_visit(node)\n                \n                global_context['current_scope_context'] = None"] RETURN n;
MERGE (n:Variable {id: "variable-func_name-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "func_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 280, \"column\": 8, \"end_line\": 280, \"end_column\": 17}", n.code_scope = "func_name" RETURN n;
MERGE (n:Variable {id: "variable-method_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "method_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 284, \"column\": 12, \"end_line\": 284, \"end_column\": 23}", n.code_scope = "method_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 305, \"column\": 16, \"end_line\": 305, \"end_column\": 28}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-previous_method-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "previous_method", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 312, \"column\": 16, \"end_line\": 312, \"end_column\": 31}", n.code_scope = "previous_method" RETURN n;
MERGE (n:Variable {id: "variable-func_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "func_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 322, \"column\": 12, \"end_line\": 322, \"end_column\": 21}", n.code_scope = "func_node" RETURN n;
MERGE (n:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_Assign", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 348, \"column\": 4, \"end_line\": 404, \"end_column\": 32}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_Assign(self, node):\n        \\\"\\\"\\\"Handle variable assignments\\\"\\\"\\\"\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                var_name = target.id\n                var_node = create_entity_node(\n                    NODE_TYPES['VARIABLE'],\n                    var_name,\n                    self.file_path,\n                    self.get_location_info(target),\n                    {},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(var_node):\n                    # Track in current scope\n                    self.scope_tracker['declared_variables'][var_name] = var_node['id']\n                    \n                    # Handle variable initialization references\n                    if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                        callee_name = node.value.func.id\n                        if callee_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][callee_name],\n                                REL_TYPES['CALLS']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    elif isinstance(node.value, ast.Name):\n                        init_name = node.value.id\n                        if init_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][init_name],\n                                REL_TYPES['REFERENCES']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    \n                    # Connect to parent scope\n                    if self.scope_tracker['current_method']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_method'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n                    elif self.scope_tracker['current_class']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_class'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)", n.content_lists = ["def visit_Assign(self, node):\n        \"\"\"Handle variable assignments\"\"\"\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                var_name = target.id\n                var_node = create_entity_node(\n                    NODE_TYPES['VARIABLE'],\n                    var_name,\n                    self.file_path,\n                    self.get_location_info(target),\n                    {},\n                    self.source_code,\n                    self.graph,\n                    self.config\n                )\n                \n                if not is_placeholder(var_node):\n                    # Track in current scope\n                    self.scope_tracker['declared_variables'][var_name] = var_node['id']\n                    \n                    # Handle variable initialization references\n                    if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):\n                        callee_name = node.value.func.id\n                        if callee_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][callee_name],\n                                REL_TYPES['CALLS']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    elif isinstance(node.value, ast.Name):\n                        init_name = node.value.id\n                        if init_name in self.scope_tracker['declared_variables']:\n                            relationship = create_relationship(\n                                var_node['id'],\n                                self.scope_tracker['declared_variables'][init_name],\n                                REL_TYPES['REFERENCES']\n                            )\n                            self.graph['relationships'].append(relationship)\n                    \n                    # Connect to parent scope\n                    if self.scope_tracker['current_method']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_method'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n                    elif self.scope_tracker['current_class']:\n                        relationship = create_relationship(\n                            self.scope_tracker['current_class'],\n                            var_node['id'],\n                            REL_TYPES['DECLARES']\n                        )\n                        self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)"] RETURN n;
MERGE (n:Variable {id: "variable-var_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "var_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 352, \"column\": 16, \"end_line\": 352, \"end_column\": 24}", n.code_scope = "var_name" RETURN n;
MERGE (n:Variable {id: "variable-var_node-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "var_node", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 353, \"column\": 16, \"end_line\": 353, \"end_column\": 24}", n.code_scope = "var_node" RETURN n;
MERGE (n:Variable {id: "variable-callee_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "callee_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 370, \"column\": 24, \"end_line\": 370, \"end_column\": 35}", n.code_scope = "callee_name" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 372, \"column\": 28, \"end_line\": 372, \"end_column\": 40}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-init_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "init_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 379, \"column\": 24, \"end_line\": 379, \"end_column\": 33}", n.code_scope = "init_name" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 381, \"column\": 28, \"end_line\": 381, \"end_column\": 40}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 390, \"column\": 24, \"end_line\": 390, \"end_column\": 36}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 397, \"column\": 24, \"end_line\": 397, \"end_column\": 36}", n.code_scope = "relationship" RETURN n;
MERGE (n:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}) ON CREATE SET n.type = "Method", n.name = "visit_Call", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 406, \"column\": 4, \"end_line\": 429, \"end_column\": 32}", n.is_async = false, n.is_generator = false, n.parent_class = "PythonASTVisitor", n.decorators = [], n.code_scope = "def visit_Call(self, node):\n        \\\"\\\"\\\"Handle function calls\\\"\\\"\\\"\n        if isinstance(node.func, ast.Name):\n            callee_name = node.func.id\n            \n            # Regular function calls\n            if callee_name in self.scope_tracker['declared_variables']:\n                # Create a relationship from current scope to the called function\n                source_id = None\n                if self.scope_tracker['current_method']:\n                    source_id = self.scope_tracker['current_method']\n                elif self.scope_tracker['current_class']:\n                    source_id = self.scope_tracker['current_class']\n                else:\n                    source_id = self.file_node['id']\n                \n                relationship = create_relationship(\n                    source_id,\n                    self.scope_tracker['declared_variables'][callee_name],\n                    REL_TYPES['CALLS']\n                )\n                self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)", n.content_lists = ["def visit_Call(self, node):\n        \"\"\"Handle function calls\"\"\"\n        if isinstance(node.func, ast.Name):\n            callee_name = node.func.id\n            \n            # Regular function calls\n            if callee_name in self.scope_tracker['declared_variables']:\n                # Create a relationship from current scope to the called function\n                source_id = None\n                if self.scope_tracker['current_method']:\n                    source_id = self.scope_tracker['current_method']\n                elif self.scope_tracker['current_class']:\n                    source_id = self.scope_tracker['current_class']\n                else:\n                    source_id = self.file_node['id']\n                \n                relationship = create_relationship(\n                    source_id,\n                    self.scope_tracker['declared_variables'][callee_name],\n                    REL_TYPES['CALLS']\n                )\n                self.graph['relationships'].append(relationship)\n        \n        self.generic_visit(node)"] RETURN n;
MERGE (n:Variable {id: "variable-callee_name-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "callee_name", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 409, \"column\": 12, \"end_line\": 409, \"end_column\": 23}", n.code_scope = "callee_name" RETURN n;
MERGE (n:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_id", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 414, \"column\": 16, \"end_line\": 414, \"end_column\": 25}", n.code_scope = "source_id" RETURN n;
MERGE (n:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_id", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 416, \"column\": 20, \"end_line\": 416, \"end_column\": 29}", n.code_scope = "source_id" RETURN n;
MERGE (n:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_id", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 418, \"column\": 20, \"end_line\": 418, \"end_column\": 29}", n.code_scope = "source_id" RETURN n;
MERGE (n:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_id", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 420, \"column\": 20, \"end_line\": 420, \"end_column\": 29}", n.code_scope = "source_id" RETURN n;
MERGE (n:Variable {id: "variable-relationship-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 422, \"column\": 16, \"end_line\": 422, \"end_column\": 28}", n.code_scope = "relationship" RETURN n;
MERGE (n:Function {id: "function-analyze_file-ast_analyzer-L0"}) ON CREATE SET n.type = "Function", n.name = "analyze_file", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 431, \"column\": 0, \"end_line\": 449, \"end_column\": 55}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def analyze_file(file_path, graph, config):\n    \\\"\\\"\\\"Analyze a Python file and extract its structure\\\"\\\"\\\"\n    print(f\\\"Analyzing file: {file_path}\\\")\n    \n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            source_code = f.read()\n        \n        # Parse the AST\n        tree = ast.parse(source_code, filename=file_path)\n        \n        # Create and run the visitor\n        visitor = PythonASTVisitor(file_path, source_code, graph, config)\n        visitor.visit(tree)\n        \n    except SyntaxError as e:\n        print(f\\\"Syntax error in {file_path}: {e}\\\")\n    except Exception as e:\n        print(f\\\"Error analyzing file {file_path}: {e}\\\")" RETURN n;
MERGE (n:Variable {id: "variable-source_code-analyze_file-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_code", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 437, \"column\": 12, \"end_line\": 437, \"end_column\": 23}", n.code_scope = "source_code" RETURN n;
MERGE (n:Variable {id: "variable-tree-analyze_file-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "tree", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 440, \"column\": 8, \"end_line\": 440, \"end_column\": 12}", n.code_scope = "tree" RETURN n;
MERGE (n:Variable {id: "variable-visitor-analyze_file-ast_analyzer-L0"}) ON CREATE SET n.type = "Variable", n.name = "visitor", n.file_path = ".\\ast_analyzer.py", n.location = "{\"line\": 443, \"column\": 8, \"end_line\": 443, \"end_column\": 15}", n.code_scope = "visitor" RETURN n;
MERGE (n:File {id: "file-constants.py-Y29uc3Rh"}) ON CREATE SET n.type = "File", n.name = "constants.py", n.file_path = ".\\constants.py", n.file_size = 2111, n.line_count = 68, n.content_lists = ["\"\"\"\nConstants for Python Code Indexer\n\"\"\"\n\n# Node Types\nNODE_TYPES = {\n    'FOLDER': 'Folder',\n    'FILE': 'File',\n    'CLASS': 'Class',\n    'METHOD': 'Method',\n    'VARIABLE': 'Variable',\n    'FUNCTION': 'Function',\n    'IMPORT': 'Import',\n    'EXTERNAL_LIBRARY': 'ExternalLibrary'\n}\n\n# Relationship Types\nREL_TYPES = {\n    'CONTAINS': 'CONTAINS',\n    'IMPORTS': 'IMPORTS',\n    'CALLS': 'CALLS',\n    'EXTENDS': 'EXTENDS',\n    'IMPLEMENTS': 'IMPLEMENTS',\n    'REFERENCES': 'REFERENCES',\n    'DECLARES': 'DECLARES'\n}\n\n# Default Configuration\nDEFAULT_CONFIG = {\n    'include_variables': False,\n    'include_imports': True,\n    'include_folders': True,\n    'include_files': True,\n    'include_classes': True,\n    'include_methods': True,\n    'include_functions': True,\n    'ignore_venv': True,\n    'track_external_libraries': False,\n    'capture_content': True\n}\n\n# Virtual environment directories to ignore\nVENV_DIRS = {\n    'venv', 'env', '.venv', '.env', 'virtualenv', \n    '__pycache__', '.git', '.pytest_cache', \n    'node_modules', '.mypy_cache', '.tox',\n    'site-packages', 'dist', 'build', 'egg-info'\n}\n\n# Python file extensions\nPYTHON_EXTENSIONS = {'.py', '.pyx', '.pyi'}\n\n# Standard library modules (subset - most commonly used)\nSTANDARD_LIBRARY_MODULES = {\n    'os', 'sys', 'json', 'time', 'datetime', 'math', 'random', 'string',\n    'collections', 'itertools', 'functools', 'operator', 'typing',\n    'pathlib', 'tempfile', 'shutil', 'glob', 'fnmatch', 'linecache',\n    'pickle', 'csv', 'xml', 'html', 'urllib', 'http', 'email',\n    'base64', 'hashlib', 'hmac', 'secrets', 'ssl', 'socket',\n    'threading', 'multiprocessing', 'concurrent', 'asyncio',\n    'logging', 'warnings', 'traceback', 'inspect', 'gc',\n    'weakref', 'copy', 'pprint', 'reprlib', 'enum', 'dataclasses',\n    'contextlib', 'abc', 'atexit', 'argparse', 'getopt', 'readline',\n    'subprocess', 'platform', 'ctypes', 'struct', 'codecs',\n    'unicodedata', 'stringprep', 'io', 'mmap', 'select', 'selectors',\n    'signal', 'errno', 'stat', 'filecmp', 'zipfile', 'tarfile',\n    'gzip', 'bz2', 'lzma', 'zlib', 'sqlite3', 'dbm', 'shelve'\n} "] RETURN n;
MERGE (n:Variable {id: "variable-NODE_TYPES--constants-L0"}) ON CREATE SET n.type = "Variable", n.name = "NODE_TYPES", n.file_path = ".\\constants.py", n.location = "{\"line\": 6, \"column\": 0, \"end_line\": 6, \"end_column\": 10}", n.code_scope = "NODE_TYPES" RETURN n;
MERGE (n:Variable {id: "variable-REL_TYPES--constants-L0"}) ON CREATE SET n.type = "Variable", n.name = "REL_TYPES", n.file_path = ".\\constants.py", n.location = "{\"line\": 18, \"column\": 0, \"end_line\": 18, \"end_column\": 9}", n.code_scope = "REL_TYPES" RETURN n;
MERGE (n:Variable {id: "variable-DEFAULT_CONFIG--constants-L0"}) ON CREATE SET n.type = "Variable", n.name = "DEFAULT_CONFIG", n.file_path = ".\\constants.py", n.location = "{\"line\": 29, \"column\": 0, \"end_line\": 29, \"end_column\": 14}", n.code_scope = "DEFAULT_CONFIG" RETURN n;
MERGE (n:Variable {id: "variable-VENV_DIRS--constants-L0"}) ON CREATE SET n.type = "Variable", n.name = "VENV_DIRS", n.file_path = ".\\constants.py", n.location = "{\"line\": 43, \"column\": 0, \"end_line\": 43, \"end_column\": 9}", n.code_scope = "VENV_DIRS" RETURN n;
MERGE (n:Variable {id: "variable-PYTHON_EXTENSIONS--constants-L0"}) ON CREATE SET n.type = "Variable", n.name = "PYTHON_EXTENSIONS", n.file_path = ".\\constants.py", n.location = "{\"line\": 51, \"column\": 0, \"end_line\": 51, \"end_column\": 17}", n.code_scope = "PYTHON_EXTENSIONS" RETURN n;
MERGE (n:Variable {id: "variable-STANDARD_LIBRARY_MODULES--constants-L0"}) ON CREATE SET n.type = "Variable", n.name = "STANDARD_LIBRARY_MODULES", n.file_path = ".\\constants.py", n.location = "{\"line\": 54, \"column\": 0, \"end_line\": 54, \"end_column\": 24}", n.code_scope = "STANDARD_LIBRARY_MODULES" RETURN n;
MERGE (n:File {id: "file-exporters.py-ZXhwb3J0"}) ON CREATE SET n.type = "File", n.name = "exporters.py", n.file_path = ".\\exporters.py", n.file_size = 7596, n.line_count = 179, n.content_lists = ["\"\"\"\nExport functions for Python Code Indexer\nHandles exporting the graph to JSON and Neo4j Cypher format\n\"\"\"\nimport json\nimport os\nfrom datetime import datetime\nfrom constants import NODE_TYPES, REL_TYPES\nfrom helpers import is_placeholder, content_registry\n\ndef export_to_json(graph, file_path):\n    \"\"\"Export the graph to JSON format\"\"\"\n    print(f\"[export_to_json] Exporting relationships: {len(graph.get('relationships', []))}\")\n    \n    # Filter out invalid relationships\n    valid_relationships = []\n    node_ids = set(node['id'] for node in graph['nodes'])\n    \n    for rel in graph['relationships']:\n        # Skip if source or target is null, undefined or a placeholder\n        if not rel.get('source') or not rel.get('target'):\n            continue\n        if is_placeholder(rel['source']) or is_placeholder(rel['target']):\n            continue\n        \n        # Skip if source or target node doesn't exist in the graph\n        if rel['source'] not in node_ids or rel['target'] not in node_ids:\n            continue\n        \n        valid_relationships.append(rel)\n    \n    # Enhance nodes with content lists\n    enhanced_nodes = []\n    for node in graph['nodes']:\n        enhanced_node = dict(node)\n        \n        # Add content lists for applicable node types\n        if node['type'] in [NODE_TYPES['FOLDER'], NODE_TYPES['FILE'], NODE_TYPES['CLASS'], NODE_TYPES['METHOD']]:\n            content_lists = get_content_lists_by_name(node['name'], node['type'])\n            if content_lists:\n                enhanced_node['content_lists'] = content_lists\n        \n        enhanced_nodes.append(enhanced_node)\n    \n    cleaned_graph = {\n        'nodes': enhanced_nodes,\n        'relationships': valid_relationships,\n        'content_registry_summary': {\n            'folders': len(content_registry['folder_contents']),\n            'files': len(content_registry['file_contents']),\n            'classes': len(content_registry['class_scopes']),\n            'methods': len(content_registry['method_scopes'])\n        }\n    }\n    \n    try:\n        with open(file_path, 'w', encoding='utf-8') as f:\n            json.dump(cleaned_graph, f, indent=2, ensure_ascii=False, default=str)\n        print(f\"[export_to_json] Graph exported to {file_path}\")\n    except Exception as e:\n        print(f\"[export_to_json] Error exporting graph: {e}\")\n        raise\n\ndef get_content_lists_by_name(name, node_type):\n    \"\"\"Get content lists for a node by name and type\"\"\"\n    registry = None\n    if node_type == NODE_TYPES['FOLDER']:\n        registry = content_registry['folder_contents']\n    elif node_type == NODE_TYPES['FILE']:\n        registry = content_registry['file_contents']\n    elif node_type == NODE_TYPES['CLASS']:\n        registry = content_registry['class_scopes']\n    elif node_type == NODE_TYPES['METHOD']:\n        registry = content_registry['method_scopes']\n    else:\n        return None\n    \n    return registry.get(name, [])\n\ndef export_to_neo4j(graph, config):\n    \"\"\"Export the graph to Neo4j Cypher format\"\"\"\n    print('[export_to_neo4j] Starting export')\n    print(f'[export_to_neo4j] Entities: {len(graph[\"nodes\"])}')\n    \n    # Filter out invalid relationships\n    valid_relationships = []\n    node_ids = set(node['id'] for node in graph['nodes'])\n    \n    for rel in graph['relationships']:\n        if not rel.get('source') or not rel.get('target'):\n            continue\n        if is_placeholder(rel['source']) or is_placeholder(rel['target']):\n            continue\n        \n        source_exists = rel['source'] in node_ids\n        target_exists = rel['target'] in node_ids\n        if source_exists and target_exists:\n            valid_relationships.append(rel)\n    \n    print(f'[export_to_neo4j] Valid relationships count: {len(valid_relationships)}')\n    \n    # Create constraints and indexes\n    constraints = [\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Folder) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:File) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Class) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Method) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Function) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Variable) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Import) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:ExternalLibrary) REQUIRE n.id IS UNIQUE',\n        'CREATE INDEX IF NOT EXISTS FOR (n:Folder) ON (n.name)',\n        'CREATE INDEX IF NOT EXISTS FOR (n:File) ON (n.name)'\n    ]\n    constraints_query = ';\\n'.join(constraints)\n    \n    # Create Cypher queries for nodes\n    nodes_queries = []\n    for node in graph['nodes']:\n        props = dict(node)\n        del props['id']  # Remove 'id' since it's used in MERGE\n        \n        # Add content lists if applicable\n        if config.get('capture_content'):\n            if node['type'] in [NODE_TYPES['FOLDER'], NODE_TYPES['FILE'], NODE_TYPES['CLASS'], NODE_TYPES['METHOD']]:\n                content_lists = get_content_lists_by_name(node['name'], node['type'])\n                if content_lists:\n                    props['content_lists'] = content_lists\n        \n        # Build property entries\n        prop_entries = []\n        for k, v in props.items():\n            if v is not None:\n                if k == 'code_scope' and isinstance(v, str):\n                    # Escape the code_scope property explicitly\n                    escaped = v.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"')\n                    prop_entries.append(f'n.{k} = {json.dumps(escaped)}')\n                elif isinstance(v, dict) and not isinstance(v, list):\n                    # Handle nested objects (store as JSON string)\n                    prop_entries.append(f'n.{k} = {json.dumps(json.dumps(v))}')\n                else:\n                    prop_entries.append(f'n.{k} = {json.dumps(v, default=str)}')\n        \n        prop_string = ', '.join(prop_entries)\n        query = f'MERGE (n:{node[\"type\"]} {{id: {json.dumps(node[\"id\"])}}}) ON CREATE SET {prop_string} RETURN n'\n        nodes_queries.append(query)\n    \n    nodes_query = ';\\n'.join(nodes_queries)\n    \n    # Create Cypher queries for relationships\n    rels_queries = []\n    for rel in valid_relationships:\n        source_node = next((n for n in graph['nodes'] if n['id'] == rel['source']), None)\n        target_node = next((n for n in graph['nodes'] if n['id'] == rel['target']), None)\n        \n        if not source_node or not target_node or source_node['id'] == target_node['id']:\n            continue\n        \n        query = (f'MATCH (a:{source_node[\"type\"]} {{id: {json.dumps(source_node[\"id\"])}}}),'\n                f' (b:{target_node[\"type\"]} {{id: {json.dumps(target_node[\"id\"])}}}) '\n                f'WHERE a <> b MERGE (a)-[r:{rel[\"type\"]}]->(b) '\n                f'ON CREATE SET r.id = {json.dumps(rel[\"id\"])} RETURN r')\n        rels_queries.append(query)\n    \n    rels_query = ';\\n'.join(rels_queries)\n    \n    # Summary statistics\n    stats = f\"\"\"// Export summary:\n  // - {len(graph['nodes'])} nodes\n  // - {len(valid_relationships)} relationships\n  // - {len(set(node['type'] for node in graph['nodes']))} node types\n  // - {len(set(rel['type'] for rel in valid_relationships))} relationship types\n  // Exported on: {datetime.now().isoformat()}\"\"\"\n    \n    # Combine everything\n    transaction = f\"{constraints_query};\\n{nodes_query};\\n{rels_query};\"\n    \n    print('[export_to_neo4j] Export query constructed')\n    return f\"{stats}\\n\\n{transaction}\" "] RETURN n;
MERGE (n:Import {id: "import-json"}) ON CREATE SET n.type = "Import", n.name = "json", n.file_path = ".\\exporters.py", n.location = "{\"line\": 5, \"column\": 0, \"end_line\": 5, \"end_column\": 11}", n.as_name = "json", n.code_scope = "import json" RETURN n;
MERGE (n:Import {id: "import-os"}) ON CREATE SET n.type = "Import", n.name = "os", n.file_path = ".\\exporters.py", n.location = "{\"line\": 6, \"column\": 0, \"end_line\": 6, \"end_column\": 9}", n.as_name = "os", n.code_scope = "import os" RETURN n;
MERGE (n:Import {id: "import-datetime_datetime"}) ON CREATE SET n.type = "Import", n.name = "datetime.datetime", n.file_path = ".\\exporters.py", n.location = "{\"line\": 7, \"column\": 0, \"end_line\": 7, \"end_column\": 29}", n.from_module = "datetime", n.import_name = "datetime", n.as_name = "datetime", n.code_scope = "from datetime import datetime" RETURN n;
MERGE (n:Function {id: "function-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Function", n.name = "export_to_json", n.file_path = ".\\exporters.py", n.location = "{\"line\": 11, \"column\": 0, \"end_line\": 62, \"end_column\": 13}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def export_to_json(graph, file_path):\n    \\\"\\\"\\\"Export the graph to JSON format\\\"\\\"\\\"\n    print(f\\\"[export_to_json] Exporting relationships: {len(graph.get('relationships', []))}\\\")\n    \n    # Filter out invalid relationships\n    valid_relationships = []\n    node_ids = set(node['id'] for node in graph['nodes'])\n    \n    for rel in graph['relationships']:\n        # Skip if source or target is null, undefined or a placeholder\n        if not rel.get('source') or not rel.get('target'):\n            continue\n        if is_placeholder(rel['source']) or is_placeholder(rel['target']):\n            continue\n        \n        # Skip if source or target node doesn't exist in the graph\n        if rel['source'] not in node_ids or rel['target'] not in node_ids:\n            continue\n        \n        valid_relationships.append(rel)\n    \n    # Enhance nodes with content lists\n    enhanced_nodes = []\n    for node in graph['nodes']:\n        enhanced_node = dict(node)\n        \n        # Add content lists for applicable node types\n        if node['type'] in [NODE_TYPES['FOLDER'], NODE_TYPES['FILE'], NODE_TYPES['CLASS'], NODE_TYPES['METHOD']]:\n            content_lists = get_content_lists_by_name(node['name'], node['type'])\n            if content_lists:\n                enhanced_node['content_lists'] = content_lists\n        \n        enhanced_nodes.append(enhanced_node)\n    \n    cleaned_graph = {\n        'nodes': enhanced_nodes,\n        'relationships': valid_relationships,\n        'content_registry_summary': {\n            'folders': len(content_registry['folder_contents']),\n            'files': len(content_registry['file_contents']),\n            'classes': len(content_registry['class_scopes']),\n            'methods': len(content_registry['method_scopes'])\n        }\n    }\n    \n    try:\n        with open(file_path, 'w', encoding='utf-8') as f:\n            json.dump(cleaned_graph, f, indent=2, ensure_ascii=False, default=str)\n        print(f\\\"[export_to_json] Graph exported to {file_path}\\\")\n    except Exception as e:\n        print(f\\\"[export_to_json] Error exporting graph: {e}\\\")\n        raise" RETURN n;
MERGE (n:Variable {id: "variable-valid_relationships-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "valid_relationships", n.file_path = ".\\exporters.py", n.location = "{\"line\": 16, \"column\": 4, \"end_line\": 16, \"end_column\": 23}", n.code_scope = "valid_relationships" RETURN n;
MERGE (n:Variable {id: "variable-node_ids-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_ids", n.file_path = ".\\exporters.py", n.location = "{\"line\": 17, \"column\": 4, \"end_line\": 17, \"end_column\": 12}", n.code_scope = "node_ids" RETURN n;
MERGE (n:Variable {id: "variable-enhanced_nodes-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "enhanced_nodes", n.file_path = ".\\exporters.py", n.location = "{\"line\": 33, \"column\": 4, \"end_line\": 33, \"end_column\": 18}", n.code_scope = "enhanced_nodes" RETURN n;
MERGE (n:Variable {id: "variable-enhanced_node-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "enhanced_node", n.file_path = ".\\exporters.py", n.location = "{\"line\": 35, \"column\": 8, \"end_line\": 35, \"end_column\": 21}", n.code_scope = "enhanced_node" RETURN n;
MERGE (n:Variable {id: "variable-content_lists-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "content_lists", n.file_path = ".\\exporters.py", n.location = "{\"line\": 39, \"column\": 12, \"end_line\": 39, \"end_column\": 25}", n.code_scope = "content_lists" RETURN n;
MERGE (n:Variable {id: "variable-cleaned_graph-export_to_json-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "cleaned_graph", n.file_path = ".\\exporters.py", n.location = "{\"line\": 45, \"column\": 4, \"end_line\": 45, \"end_column\": 17}", n.code_scope = "cleaned_graph" RETURN n;
MERGE (n:Function {id: "function-get_content_lists_by_name-exporters-L0"}) ON CREATE SET n.type = "Function", n.name = "get_content_lists_by_name", n.file_path = ".\\exporters.py", n.location = "{\"line\": 64, \"column\": 0, \"end_line\": 78, \"end_column\": 33}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def get_content_lists_by_name(name, node_type):\n    \\\"\\\"\\\"Get content lists for a node by name and type\\\"\\\"\\\"\n    registry = None\n    if node_type == NODE_TYPES['FOLDER']:\n        registry = content_registry['folder_contents']\n    elif node_type == NODE_TYPES['FILE']:\n        registry = content_registry['file_contents']\n    elif node_type == NODE_TYPES['CLASS']:\n        registry = content_registry['class_scopes']\n    elif node_type == NODE_TYPES['METHOD']:\n        registry = content_registry['method_scopes']\n    else:\n        return None\n    \n    return registry.get(name, [])" RETURN n;
MERGE (n:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\exporters.py", n.location = "{\"line\": 66, \"column\": 4, \"end_line\": 66, \"end_column\": 12}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\exporters.py", n.location = "{\"line\": 68, \"column\": 8, \"end_line\": 68, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\exporters.py", n.location = "{\"line\": 70, \"column\": 8, \"end_line\": 70, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\exporters.py", n.location = "{\"line\": 72, \"column\": 8, \"end_line\": 72, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\exporters.py", n.location = "{\"line\": 74, \"column\": 8, \"end_line\": 74, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Function {id: "function-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Function", n.name = "export_to_neo4j", n.file_path = ".\\exporters.py", n.location = "{\"line\": 80, \"column\": 0, \"end_line\": 179, \"end_column\": 38}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def export_to_neo4j(graph, config):\n    \\\"\\\"\\\"Export the graph to Neo4j Cypher format\\\"\\\"\\\"\n    print('[export_to_neo4j] Starting export')\n    print(f'[export_to_neo4j] Entities: {len(graph[\\\"nodes\\\"])}')\n    \n    # Filter out invalid relationships\n    valid_relationships = []\n    node_ids = set(node['id'] for node in graph['nodes'])\n    \n    for rel in graph['relationships']:\n        if not rel.get('source') or not rel.get('target'):\n            continue\n        if is_placeholder(rel['source']) or is_placeholder(rel['target']):\n            continue\n        \n        source_exists = rel['source'] in node_ids\n        target_exists = rel['target'] in node_ids\n        if source_exists and target_exists:\n            valid_relationships.append(rel)\n    \n    print(f'[export_to_neo4j] Valid relationships count: {len(valid_relationships)}')\n    \n    # Create constraints and indexes\n    constraints = [\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Folder) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:File) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Class) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Method) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Function) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Variable) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Import) REQUIRE n.id IS UNIQUE',\n        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:ExternalLibrary) REQUIRE n.id IS UNIQUE',\n        'CREATE INDEX IF NOT EXISTS FOR (n:Folder) ON (n.name)',\n        'CREATE INDEX IF NOT EXISTS FOR (n:File) ON (n.name)'\n    ]\n    constraints_query = ';\\\\n'.join(constraints)\n    \n    # Create Cypher queries for nodes\n    nodes_queries = []\n    for node in graph['nodes']:\n        props = dict(node)\n        del props['id']  # Remove 'id' since it's used in MERGE\n        \n        # Add content lists if applicable\n        if config.get('capture_content'):\n            if node['type'] in [NODE_TYPES['FOLDER'], NODE_TYPES['FILE'], NODE_TYPES['CLASS'], NODE_TYPES['METHOD']]:\n                content_lists = get_content_lists_by_name(node['name'], node['type'])\n                if content_lists:\n                    props['content_lists'] = content_lists\n        \n        # Build property entries\n        prop_entries = []\n        for k, v in props.items():\n            if v is not None:\n                if k == 'code_scope' and isinstance(v, str):\n                    # Escape the code_scope property explicitly\n                    escaped = v.replace('\\\\\\\\', '\\\\\\\\\\\\\\\\').replace('\\\"', '\\\\\\\\\\\"')\n                    prop_entries.append(f'n.{k} = {json.dumps(escaped)}')\n                elif isinstance(v, dict) and not isinstance(v, list):\n                    # Handle nested objects (store as JSON string)\n                    prop_entries.append(f'n.{k} = {json.dumps(json.dumps(v))}')\n                else:\n                    prop_entries.append(f'n.{k} = {json.dumps(v, default=str)}')\n        \n        prop_string = ', '.join(prop_entries)\n        query = f'MERGE (n:{node[\\\"type\\\"]} {{id: {json.dumps(node[\\\"id\\\"])}}}) ON CREATE SET {prop_string} RETURN n'\n        nodes_queries.append(query)\n    \n    nodes_query = ';\\\\n'.join(nodes_queries)\n    \n    # Create Cypher queries for relationships\n    rels_queries = []\n    for rel in valid_relationships:\n        source_node = next((n for n in graph['nodes'] if n['id'] == rel['source']), None)\n        target_node = next((n for n in graph['nodes'] if n['id'] == rel['target']), None)\n        \n        if not source_node or not target_node or source_node['id'] == target_node['id']:\n            continue\n        \n        query = (f'MATCH (a:{source_node[\\\"type\\\"]} {{id: {json.dumps(source_node[\\\"id\\\"])}}}),'\n                f' (b:{target_node[\\\"type\\\"]} {{id: {json.dumps(target_node[\\\"id\\\"])}}}) '\n                f'WHERE a <> b MERGE (a)-[r:{rel[\\\"type\\\"]}]->(b) '\n                f'ON CREATE SET r.id = {json.dumps(rel[\\\"id\\\"])} RETURN r')\n        rels_queries.append(query)\n    \n    rels_query = ';\\\\n'.join(rels_queries)\n    \n    # Summary statistics\n    stats = f\\\"\\\"\\\"// Export summary:\n  // - {len(graph['nodes'])} nodes\n  // - {len(valid_relationships)} relationships\n  // - {len(set(node['type'] for node in graph['nodes']))} node types\n  // - {len(set(rel['type'] for rel in valid_relationships))} relationship types\n  // Exported on: {datetime.now().isoformat()}\\\"\\\"\\\"\n    \n    # Combine everything\n    transaction = f\\\"{constraints_query};\\\\n{nodes_query};\\\\n{rels_query};\\\"\n    \n    print('[export_to_neo4j] Export query constructed')\n    return f\\\"{stats}\\\\n\\\\n{transaction}\\\"" RETURN n;
MERGE (n:Variable {id: "variable-valid_relationships-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "valid_relationships", n.file_path = ".\\exporters.py", n.location = "{\"line\": 86, \"column\": 4, \"end_line\": 86, \"end_column\": 23}", n.code_scope = "valid_relationships" RETURN n;
MERGE (n:Variable {id: "variable-node_ids-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_ids", n.file_path = ".\\exporters.py", n.location = "{\"line\": 87, \"column\": 4, \"end_line\": 87, \"end_column\": 12}", n.code_scope = "node_ids" RETURN n;
MERGE (n:Variable {id: "variable-source_exists-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_exists", n.file_path = ".\\exporters.py", n.location = "{\"line\": 95, \"column\": 8, \"end_line\": 95, \"end_column\": 21}", n.code_scope = "source_exists" RETURN n;
MERGE (n:Variable {id: "variable-target_exists-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "target_exists", n.file_path = ".\\exporters.py", n.location = "{\"line\": 96, \"column\": 8, \"end_line\": 96, \"end_column\": 21}", n.code_scope = "target_exists" RETURN n;
MERGE (n:Variable {id: "variable-constraints-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "constraints", n.file_path = ".\\exporters.py", n.location = "{\"line\": 103, \"column\": 4, \"end_line\": 103, \"end_column\": 15}", n.code_scope = "constraints" RETURN n;
MERGE (n:Variable {id: "variable-constraints_query-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "constraints_query", n.file_path = ".\\exporters.py", n.location = "{\"line\": 115, \"column\": 4, \"end_line\": 115, \"end_column\": 21}", n.code_scope = "constraints_query" RETURN n;
MERGE (n:Variable {id: "variable-nodes_queries-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "nodes_queries", n.file_path = ".\\exporters.py", n.location = "{\"line\": 118, \"column\": 4, \"end_line\": 118, \"end_column\": 17}", n.code_scope = "nodes_queries" RETURN n;
MERGE (n:Variable {id: "variable-props-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "props", n.file_path = ".\\exporters.py", n.location = "{\"line\": 120, \"column\": 8, \"end_line\": 120, \"end_column\": 13}", n.code_scope = "props" RETURN n;
MERGE (n:Variable {id: "variable-content_lists-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "content_lists", n.file_path = ".\\exporters.py", n.location = "{\"line\": 126, \"column\": 16, \"end_line\": 126, \"end_column\": 29}", n.code_scope = "content_lists" RETURN n;
MERGE (n:Variable {id: "variable-prop_entries-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "prop_entries", n.file_path = ".\\exporters.py", n.location = "{\"line\": 131, \"column\": 8, \"end_line\": 131, \"end_column\": 20}", n.code_scope = "prop_entries" RETURN n;
MERGE (n:Variable {id: "variable-escaped-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "escaped", n.file_path = ".\\exporters.py", n.location = "{\"line\": 136, \"column\": 20, \"end_line\": 136, \"end_column\": 27}", n.code_scope = "escaped" RETURN n;
MERGE (n:Variable {id: "variable-prop_string-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "prop_string", n.file_path = ".\\exporters.py", n.location = "{\"line\": 144, \"column\": 8, \"end_line\": 144, \"end_column\": 19}", n.code_scope = "prop_string" RETURN n;
MERGE (n:Variable {id: "variable-query-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "query", n.file_path = ".\\exporters.py", n.location = "{\"line\": 145, \"column\": 8, \"end_line\": 145, \"end_column\": 13}", n.code_scope = "query" RETURN n;
MERGE (n:Variable {id: "variable-nodes_query-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "nodes_query", n.file_path = ".\\exporters.py", n.location = "{\"line\": 148, \"column\": 4, \"end_line\": 148, \"end_column\": 15}", n.code_scope = "nodes_query" RETURN n;
MERGE (n:Variable {id: "variable-rels_queries-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "rels_queries", n.file_path = ".\\exporters.py", n.location = "{\"line\": 151, \"column\": 4, \"end_line\": 151, \"end_column\": 16}", n.code_scope = "rels_queries" RETURN n;
MERGE (n:Variable {id: "variable-source_node-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_node", n.file_path = ".\\exporters.py", n.location = "{\"line\": 153, \"column\": 8, \"end_line\": 153, \"end_column\": 19}", n.code_scope = "source_node" RETURN n;
MERGE (n:Variable {id: "variable-target_node-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "target_node", n.file_path = ".\\exporters.py", n.location = "{\"line\": 154, \"column\": 8, \"end_line\": 154, \"end_column\": 19}", n.code_scope = "target_node" RETURN n;
MERGE (n:Variable {id: "variable-query-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "query", n.file_path = ".\\exporters.py", n.location = "{\"line\": 159, \"column\": 8, \"end_line\": 159, \"end_column\": 13}", n.code_scope = "query" RETURN n;
MERGE (n:Variable {id: "variable-rels_query-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "rels_query", n.file_path = ".\\exporters.py", n.location = "{\"line\": 165, \"column\": 4, \"end_line\": 165, \"end_column\": 14}", n.code_scope = "rels_query" RETURN n;
MERGE (n:Variable {id: "variable-stats-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "stats", n.file_path = ".\\exporters.py", n.location = "{\"line\": 168, \"column\": 4, \"end_line\": 168, \"end_column\": 9}", n.code_scope = "stats" RETURN n;
MERGE (n:Variable {id: "variable-transaction-export_to_neo4j-exporters-L0"}) ON CREATE SET n.type = "Variable", n.name = "transaction", n.file_path = ".\\exporters.py", n.location = "{\"line\": 176, \"column\": 4, \"end_line\": 176, \"end_column\": 15}", n.code_scope = "transaction" RETURN n;
MERGE (n:File {id: "file-helpers.py-aGVscGVy"}) ON CREATE SET n.type = "File", n.name = "helpers.py", n.file_path = ".\\helpers.py", n.file_size = 14138, n.line_count = 354, n.content_lists = ["\"\"\"\nHelper functions for Python Code Indexer\n\"\"\"\nimport os\nimport base64\nimport hashlib\nfrom pathlib import Path\nfrom constants import NODE_TYPES, REL_TYPES\n\n# Registries for tracking nodes and content\nnode_registry = {\n    'folder_nodes': {},\n    'file_nodes': {},\n    'entity_nodes': {}\n}\n\ncontent_registry = {\n    'folder_contents': {},\n    'file_contents': {},\n    'class_scopes': {},\n    'method_scopes': {}\n}\n\nexternal_libraries = {}\n\n# Global context for AST traversal\nglobal_context = {\n    'current_class_context': None,\n    'current_method_context': None,\n    'current_scope_context': None,\n    'current_class_node': None,\n    'current_method_node': None\n}\n\ndef is_placeholder(node_id):\n    \"\"\"Check if a node ID is a placeholder\"\"\"\n    return isinstance(node_id, str) and node_id.startswith('placeholder_')\n\ndef generate_meaningful_id(node_type, name, file_path=None, location=None):\n    \"\"\"Generate a meaningful ID for a node\"\"\"\n    # Clean up the name to use in the ID\n    clean_name = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)[:40]\n    \n    # Base format: [type]-[name]\n    node_id = f\"{node_type.lower()}-{clean_name}\"\n    \n    if node_type == NODE_TYPES['FOLDER'] and file_path:\n        folder_name = os.path.basename(file_path)\n        normalized_path = os.path.normpath(file_path).replace('\\\\', '/')\n        \n        if folder_name in ['.', '..']:\n            # Handle current/parent directory references\n            path_segments = [p for p in normalized_path.split('/') if p]\n            dir_name = path_segments[-1] if path_segments else 'root'\n            path_hash = base64.b64encode(normalized_path.encode()).decode()[:8]\n            node_id = f\"folder-{dir_name.replace('.', '_')}-{path_hash}\"\n        else:\n            # Normal folder - add path hash for uniqueness\n            clean_folder = ''.join(c if c.isalnum() or c == '_' else '_' for c in folder_name)\n            path_hash = base64.b64encode(normalized_path.encode()).decode()[:8]\n            node_id = f\"folder-{clean_folder}-{path_hash}\"\n    \n    elif node_type == NODE_TYPES['FILE'] and file_path:\n        filename = os.path.basename(file_path)\n        normalized_path = os.path.normpath(file_path).replace('\\\\', '/')\n        clean_filename = ''.join(c if c.isalnum() or c in '._' else '_' for c in filename)\n        path_hash = base64.b64encode(normalized_path.encode()).decode()[:8]\n        node_id = f\"file-{clean_filename}-{path_hash}\"\n    \n    elif node_type == NODE_TYPES['CLASS'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        node_id = f\"class-{clean_name}-{clean_filename}\"\n        \n        if location:\n            node_id += f\"-L{location.get('lineno', 0)}\"\n    \n    elif node_type == NODE_TYPES['METHOD'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        class_context = global_context['current_class_context'] or ''\n        clean_class = ''.join(c if c.isalnum() or c == '_' else '_' for c in class_context)\n        node_id = f\"method-{clean_name}-{clean_class}-{clean_filename}\"\n        \n        if location:\n            node_id += f\"-L{location.get('lineno', 0)}\"\n    \n    elif node_type == NODE_TYPES['FUNCTION'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        node_id = f\"function-{clean_name}-{clean_filename}\"\n        \n        if location:\n            node_id += f\"-L{location.get('lineno', 0)}\"\n    \n    elif node_type == NODE_TYPES['VARIABLE'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        scope_context = global_context['current_scope_context'] or ''\n        clean_scope = ''.join(c if c.isalnum() or c == '_' else '_' for c in scope_context)\n        node_id = f\"variable-{clean_name}-{clean_scope}-{clean_filename}\"\n        \n        if location:\n            node_id += f\"-L{location.get('lineno', 0)}\"\n    \n    elif node_type == NODE_TYPES['EXTERNAL_LIBRARY']:\n        node_id = f\"lib-{clean_name}\"\n    \n    return node_id\n\ndef create_node(node_type, name, file_path=None, metadata=None):\n    \"\"\"Create a node with the given parameters\"\"\"\n    if metadata is None:\n        metadata = {}\n    \n    location = metadata.get('location')\n    node_id = generate_meaningful_id(node_type, name, file_path, location)\n    \n    node = {\n        'id': node_id,\n        'type': node_type,\n        'name': name,\n        'file_path': file_path,\n        **metadata\n    }\n    \n    return node\n\ndef create_relationship(source_id, target_id, rel_type, metadata=None):\n    \"\"\"Create a relationship between two nodes\"\"\"\n    if metadata is None:\n        metadata = {}\n    \n    relationship = {\n        'id': f\"{source_id}-{rel_type}-{target_id}\",\n        'source': source_id,\n        'target': target_id,\n        'type': rel_type,\n        **metadata\n    }\n    \n    return relationship\n\ndef register_content(node_type, name, content, config):\n    \"\"\"Register content for a node if capture_content is enabled\"\"\"\n    if not config.get('capture_content'):\n        return\n    \n    registry = None\n    if node_type == NODE_TYPES['FOLDER']:\n        registry = content_registry['folder_contents']\n    elif node_type == NODE_TYPES['FILE']:\n        registry = content_registry['file_contents']\n    elif node_type == NODE_TYPES['CLASS']:\n        registry = content_registry['class_scopes']\n    elif node_type == NODE_TYPES['METHOD']:\n        registry = content_registry['method_scopes']\n    else:\n        return\n    \n    if name in registry:\n        registry[name].append(content)\n    else:\n        registry[name] = [content]\n\ndef extract_source_code(source_code, location):\n    \"\"\"Extract source code from location information\"\"\"\n    if not source_code or not location:\n        return ''\n    \n    try:\n        lines = source_code.split('\\n')\n        start_line = location.get('lineno', 1) - 1\n        end_line = location.get('end_lineno', start_line + 1) - 1\n        \n        if start_line == end_line:\n            col_offset = location.get('col_offset', 0)\n            end_col_offset = location.get('end_col_offset', len(lines[start_line]))\n            return lines[start_line][col_offset:end_col_offset]\n        else:\n            code_lines = []\n            # First line from start column to end\n            col_offset = location.get('col_offset', 0)\n            code_lines.append(lines[start_line][col_offset:])\n            \n            # Middle lines (if any)\n            for i in range(start_line + 1, end_line):\n                if i < len(lines):\n                    code_lines.append(lines[i])\n            \n            # Last line from beginning to end column\n            if end_line < len(lines):\n                end_col_offset = location.get('end_col_offset', len(lines[end_line]))\n                code_lines.append(lines[end_line][:end_col_offset])\n            \n            return '\\n'.join(code_lines)\n    except Exception as e:\n        print(f\"Error extracting source code: {e}\")\n        return ''\n\ndef get_or_create_folder_node(folder_path, graph, config):\n    \"\"\"Get or create a folder node\"\"\"\n    if folder_path in node_registry['folder_nodes']:\n        return node_registry['folder_nodes'][folder_path]\n    \n    folder_name = os.path.basename(folder_path) or folder_path\n    node = create_node(NODE_TYPES['FOLDER'], folder_name, folder_path)\n    graph['nodes'].append(node)\n    node_registry['folder_nodes'][folder_path] = node\n    \n    # Create relationship with parent folder\n    parent_path = os.path.dirname(folder_path)\n    if parent_path != folder_path and parent_path:\n        parent_node = get_or_create_folder_node(parent_path, graph, config)\n        relationship = create_relationship(parent_node['id'], node['id'], REL_TYPES['CONTAINS'])\n        graph['relationships'].append(relationship)\n    \n    # Register folder content if config allows\n    if config.get('capture_content'):\n        try:\n            if os.path.exists(folder_path):\n                items = os.listdir(folder_path)\n                folder_content = []\n                for item in items:\n                    item_path = os.path.join(folder_path, item)\n                    if os.path.isdir(item_path):\n                        folder_content.append({\n                            'name': item,\n                            'type': 'folder',\n                            'size': 0,\n                            'last_modified': os.path.getmtime(item_path)\n                        })\n                    else:\n                        folder_content.append({\n                            'name': item,\n                            'type': 'file',\n                            'size': os.path.getsize(item_path),\n                            'last_modified': os.path.getmtime(item_path)\n                        })\n                \n                folders = len([f for f in folder_content if f['type'] == 'folder'])\n                files = len([f for f in folder_content if f['type'] == 'file'])\n                node['content_count'] = len(folder_content)\n                node['content_summary'] = f\"{folders} folders, {files} files\"\n                \n                register_content(NODE_TYPES['FOLDER'], folder_name, folder_content, config)\n        except Exception as e:\n            print(f\"Error reading folder contents for {folder_path}: {e}\")\n    \n    return node\n\ndef get_or_create_file_node(file_path, graph, config):\n    \"\"\"Get or create a file node\"\"\"\n    if file_path in node_registry['file_nodes']:\n        return node_registry['file_nodes'][file_path]\n    \n    filename = os.path.basename(file_path)\n    node = create_node(NODE_TYPES['FILE'], filename, file_path)\n    graph['nodes'].append(node)\n    node_registry['file_nodes'][file_path] = node\n    \n    # Create relationship with containing folder\n    folder_path = os.path.dirname(file_path)\n    folder_node = get_or_create_folder_node(folder_path, graph, config)\n    relationship = create_relationship(folder_node['id'], node['id'], REL_TYPES['CONTAINS'])\n    graph['relationships'].append(relationship)\n    \n    # Register file content if config allows\n    if config.get('capture_content'):\n        try:\n            if os.path.exists(file_path):\n                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                    file_content = f.read()\n                    node['file_size'] = len(file_content)\n                    node['line_count'] = len(file_content.split('\\n'))\n                    \n                    register_content(NODE_TYPES['FILE'], filename, file_content, config)\n        except Exception as e:\n            print(f\"Error reading file content for {file_path}: {e}\")\n    \n    return node\n\ndef create_entity_node(node_type, name, file_path, location, metadata, source_code, graph, config):\n    \"\"\"Create an entity node (class, method, function, variable, etc.)\"\"\"\n    # Check if this type of node should be included based on configuration\n    if (\n        (node_type == NODE_TYPES['VARIABLE'] and not config.get('include_variables')) or\n        (node_type == NODE_TYPES['IMPORT'] and not config.get('include_imports')) or\n        (node_type == NODE_TYPES['CLASS'] and not config.get('include_classes')) or\n        (node_type == NODE_TYPES['METHOD'] and not config.get('include_methods')) or\n        (node_type == NODE_TYPES['FUNCTION'] and not config.get('include_functions'))\n    ):\n        # Return a placeholder id for tracking in scope but not in actual graph\n        return f\"placeholder_{node_type}_{name}\"\n    \n    key = f\"{file_path}:{node_type}:{name}:{location.get('lineno', 0)}:{location.get('col_offset', 0)}\"\n    \n    if key in node_registry['entity_nodes']:\n        return node_registry['entity_nodes'][key]\n    \n    # Add code scope content if provided\n    if config.get('capture_content') and source_code:\n        code_content = extract_source_code(source_code, location)\n        if code_content:\n            metadata['code_scope'] = code_content\n            \n            # Register content in appropriate registry\n            if node_type in [NODE_TYPES['CLASS'], NODE_TYPES['METHOD']]:\n                register_content(node_type, name, code_content, config)\n    \n    node = create_node(node_type, name, file_path, {\n        'location': {\n            'line': location.get('lineno', 0),\n            'column': location.get('col_offset', 0),\n            'end_line': location.get('end_lineno', 0),\n            'end_column': location.get('end_col_offset', 0)\n        },\n        **metadata\n    })\n    \n    graph['nodes'].append(node)\n    node_registry['entity_nodes'][key] = node\n    \n    # Create relationship with containing file\n    file_node = get_or_create_file_node(file_path, graph, config)\n    relationship = create_relationship(file_node['id'], node['id'], REL_TYPES['CONTAINS'])\n    graph['relationships'].append(relationship)\n    \n    # Update global tracking for class and method contexts\n    if node_type == NODE_TYPES['CLASS']:\n        global_context['current_class_node'] = node['id']\n    elif node_type == NODE_TYPES['METHOD']:\n        global_context['current_method_node'] = node['id']\n    \n    return node\n\ndef clear_registries():\n    \"\"\"Clear all registries for a fresh start\"\"\"\n    node_registry['folder_nodes'].clear()\n    node_registry['file_nodes'].clear()\n    node_registry['entity_nodes'].clear()\n    \n    content_registry['folder_contents'].clear()\n    content_registry['file_contents'].clear()\n    content_registry['class_scopes'].clear()\n    content_registry['method_scopes'].clear()\n    \n    external_libraries.clear()\n    \n    global_context['current_class_context'] = None\n    global_context['current_method_context'] = None\n    global_context['current_scope_context'] = None\n    global_context['current_class_node'] = None\n    global_context['current_method_node'] = None "] RETURN n;
MERGE (n:Import {id: "import-os"}) ON CREATE SET n.type = "Import", n.name = "os", n.file_path = ".\\helpers.py", n.location = "{\"line\": 4, \"column\": 0, \"end_line\": 4, \"end_column\": 9}", n.as_name = "os", n.code_scope = "import os" RETURN n;
MERGE (n:Import {id: "import-base64"}) ON CREATE SET n.type = "Import", n.name = "base64", n.file_path = ".\\helpers.py", n.location = "{\"line\": 5, \"column\": 0, \"end_line\": 5, \"end_column\": 13}", n.as_name = "base64", n.code_scope = "import base64" RETURN n;
MERGE (n:Import {id: "import-hashlib"}) ON CREATE SET n.type = "Import", n.name = "hashlib", n.file_path = ".\\helpers.py", n.location = "{\"line\": 6, \"column\": 0, \"end_line\": 6, \"end_column\": 14}", n.as_name = "hashlib", n.code_scope = "import hashlib" RETURN n;
MERGE (n:Import {id: "import-pathlib_Path"}) ON CREATE SET n.type = "Import", n.name = "pathlib.Path", n.file_path = ".\\helpers.py", n.location = "{\"line\": 7, \"column\": 0, \"end_line\": 7, \"end_column\": 24}", n.from_module = "pathlib", n.import_name = "Path", n.as_name = "Path", n.code_scope = "from pathlib import Path" RETURN n;
MERGE (n:Variable {id: "variable-node_registry--helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 11, \"column\": 0, \"end_line\": 11, \"end_column\": 13}", n.code_scope = "node_registry" RETURN n;
MERGE (n:Variable {id: "variable-content_registry--helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "content_registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 17, \"column\": 0, \"end_line\": 17, \"end_column\": 16}", n.code_scope = "content_registry" RETURN n;
MERGE (n:Variable {id: "variable-external_libraries--helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "external_libraries", n.file_path = ".\\helpers.py", n.location = "{\"line\": 24, \"column\": 0, \"end_line\": 24, \"end_column\": 18}", n.code_scope = "external_libraries" RETURN n;
MERGE (n:Variable {id: "variable-global_context--helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "global_context", n.file_path = ".\\helpers.py", n.location = "{\"line\": 27, \"column\": 0, \"end_line\": 27, \"end_column\": 14}", n.code_scope = "global_context" RETURN n;
MERGE (n:Function {id: "function-is_placeholder-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "is_placeholder", n.file_path = ".\\helpers.py", n.location = "{\"line\": 35, \"column\": 0, \"end_line\": 37, \"end_column\": 74}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def is_placeholder(node_id):\n    \\\"\\\"\\\"Check if a node ID is a placeholder\\\"\\\"\\\"\n    return isinstance(node_id, str) and node_id.startswith('placeholder_')" RETURN n;
MERGE (n:Function {id: "function-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "generate_meaningful_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 39, \"column\": 0, \"end_line\": 109, \"end_column\": 18}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def generate_meaningful_id(node_type, name, file_path=None, location=None):\n    \\\"\\\"\\\"Generate a meaningful ID for a node\\\"\\\"\\\"\n    # Clean up the name to use in the ID\n    clean_name = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)[:40]\n    \n    # Base format: [type]-[name]\n    node_id = f\\\"{node_type.lower()}-{clean_name}\\\"\n    \n    if node_type == NODE_TYPES['FOLDER'] and file_path:\n        folder_name = os.path.basename(file_path)\n        normalized_path = os.path.normpath(file_path).replace('\\\\\\\\', '/')\n        \n        if folder_name in ['.', '..']:\n            # Handle current/parent directory references\n            path_segments = [p for p in normalized_path.split('/') if p]\n            dir_name = path_segments[-1] if path_segments else 'root'\n            path_hash = base64.b64encode(normalized_path.encode()).decode()[:8]\n            node_id = f\\\"folder-{dir_name.replace('.', '_')}-{path_hash}\\\"\n        else:\n            # Normal folder - add path hash for uniqueness\n            clean_folder = ''.join(c if c.isalnum() or c == '_' else '_' for c in folder_name)\n            path_hash = base64.b64encode(normalized_path.encode()).decode()[:8]\n            node_id = f\\\"folder-{clean_folder}-{path_hash}\\\"\n    \n    elif node_type == NODE_TYPES['FILE'] and file_path:\n        filename = os.path.basename(file_path)\n        normalized_path = os.path.normpath(file_path).replace('\\\\\\\\', '/')\n        clean_filename = ''.join(c if c.isalnum() or c in '._' else '_' for c in filename)\n        path_hash = base64.b64encode(normalized_path.encode()).decode()[:8]\n        node_id = f\\\"file-{clean_filename}-{path_hash}\\\"\n    \n    elif node_type == NODE_TYPES['CLASS'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        node_id = f\\\"class-{clean_name}-{clean_filename}\\\"\n        \n        if location:\n            node_id += f\\\"-L{location.get('lineno', 0)}\\\"\n    \n    elif node_type == NODE_TYPES['METHOD'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        class_context = global_context['current_class_context'] or ''\n        clean_class = ''.join(c if c.isalnum() or c == '_' else '_' for c in class_context)\n        node_id = f\\\"method-{clean_name}-{clean_class}-{clean_filename}\\\"\n        \n        if location:\n            node_id += f\\\"-L{location.get('lineno', 0)}\\\"\n    \n    elif node_type == NODE_TYPES['FUNCTION'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        node_id = f\\\"function-{clean_name}-{clean_filename}\\\"\n        \n        if location:\n            node_id += f\\\"-L{location.get('lineno', 0)}\\\"\n    \n    elif node_type == NODE_TYPES['VARIABLE'] and file_path:\n        filename = os.path.splitext(os.path.basename(file_path))[0]\n        clean_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename)\n        scope_context = global_context['current_scope_context'] or ''\n        clean_scope = ''.join(c if c.isalnum() or c == '_' else '_' for c in scope_context)\n        node_id = f\\\"variable-{clean_name}-{clean_scope}-{clean_filename}\\\"\n        \n        if location:\n            node_id += f\\\"-L{location.get('lineno', 0)}\\\"\n    \n    elif node_type == NODE_TYPES['EXTERNAL_LIBRARY']:\n        node_id = f\\\"lib-{clean_name}\\\"\n    \n    return node_id" RETURN n;
MERGE (n:Variable {id: "variable-clean_name-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_name", n.file_path = ".\\helpers.py", n.location = "{\"line\": 42, \"column\": 4, \"end_line\": 42, \"end_column\": 14}", n.code_scope = "clean_name" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 45, \"column\": 4, \"end_line\": 45, \"end_column\": 11}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-folder_name-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "folder_name", n.file_path = ".\\helpers.py", n.location = "{\"line\": 48, \"column\": 8, \"end_line\": 48, \"end_column\": 19}", n.code_scope = "folder_name" RETURN n;
MERGE (n:Variable {id: "variable-normalized_path-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "normalized_path", n.file_path = ".\\helpers.py", n.location = "{\"line\": 49, \"column\": 8, \"end_line\": 49, \"end_column\": 23}", n.code_scope = "normalized_path" RETURN n;
MERGE (n:Variable {id: "variable-path_segments-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "path_segments", n.file_path = ".\\helpers.py", n.location = "{\"line\": 53, \"column\": 12, \"end_line\": 53, \"end_column\": 25}", n.code_scope = "path_segments" RETURN n;
MERGE (n:Variable {id: "variable-dir_name-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "dir_name", n.file_path = ".\\helpers.py", n.location = "{\"line\": 54, \"column\": 12, \"end_line\": 54, \"end_column\": 20}", n.code_scope = "dir_name" RETURN n;
MERGE (n:Variable {id: "variable-path_hash-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "path_hash", n.file_path = ".\\helpers.py", n.location = "{\"line\": 55, \"column\": 12, \"end_line\": 55, \"end_column\": 21}", n.code_scope = "path_hash" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 56, \"column\": 12, \"end_line\": 56, \"end_column\": 19}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-clean_folder-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_folder", n.file_path = ".\\helpers.py", n.location = "{\"line\": 59, \"column\": 12, \"end_line\": 59, \"end_column\": 24}", n.code_scope = "clean_folder" RETURN n;
MERGE (n:Variable {id: "variable-path_hash-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "path_hash", n.file_path = ".\\helpers.py", n.location = "{\"line\": 60, \"column\": 12, \"end_line\": 60, \"end_column\": 21}", n.code_scope = "path_hash" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 61, \"column\": 12, \"end_line\": 61, \"end_column\": 19}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 64, \"column\": 8, \"end_line\": 64, \"end_column\": 16}", n.code_scope = "filename" RETURN n;
MERGE (n:Variable {id: "variable-normalized_path-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "normalized_path", n.file_path = ".\\helpers.py", n.location = "{\"line\": 65, \"column\": 8, \"end_line\": 65, \"end_column\": 23}", n.code_scope = "normalized_path" RETURN n;
MERGE (n:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 66, \"column\": 8, \"end_line\": 66, \"end_column\": 22}", n.code_scope = "clean_filename" RETURN n;
MERGE (n:Variable {id: "variable-path_hash-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "path_hash", n.file_path = ".\\helpers.py", n.location = "{\"line\": 67, \"column\": 8, \"end_line\": 67, \"end_column\": 17}", n.code_scope = "path_hash" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 68, \"column\": 8, \"end_line\": 68, \"end_column\": 15}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 71, \"column\": 8, \"end_line\": 71, \"end_column\": 16}", n.code_scope = "filename" RETURN n;
MERGE (n:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 72, \"column\": 8, \"end_line\": 72, \"end_column\": 22}", n.code_scope = "clean_filename" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 73, \"column\": 8, \"end_line\": 73, \"end_column\": 15}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 79, \"column\": 8, \"end_line\": 79, \"end_column\": 16}", n.code_scope = "filename" RETURN n;
MERGE (n:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 80, \"column\": 8, \"end_line\": 80, \"end_column\": 22}", n.code_scope = "clean_filename" RETURN n;
MERGE (n:Variable {id: "variable-class_context-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "class_context", n.file_path = ".\\helpers.py", n.location = "{\"line\": 81, \"column\": 8, \"end_line\": 81, \"end_column\": 21}", n.code_scope = "class_context" RETURN n;
MERGE (n:Variable {id: "variable-clean_class-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_class", n.file_path = ".\\helpers.py", n.location = "{\"line\": 82, \"column\": 8, \"end_line\": 82, \"end_column\": 19}", n.code_scope = "clean_class" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 83, \"column\": 8, \"end_line\": 83, \"end_column\": 15}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 89, \"column\": 8, \"end_line\": 89, \"end_column\": 16}", n.code_scope = "filename" RETURN n;
MERGE (n:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 90, \"column\": 8, \"end_line\": 90, \"end_column\": 22}", n.code_scope = "clean_filename" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 91, \"column\": 8, \"end_line\": 91, \"end_column\": 15}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 97, \"column\": 8, \"end_line\": 97, \"end_column\": 16}", n.code_scope = "filename" RETURN n;
MERGE (n:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 98, \"column\": 8, \"end_line\": 98, \"end_column\": 22}", n.code_scope = "clean_filename" RETURN n;
MERGE (n:Variable {id: "variable-scope_context-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "scope_context", n.file_path = ".\\helpers.py", n.location = "{\"line\": 99, \"column\": 8, \"end_line\": 99, \"end_column\": 21}", n.code_scope = "scope_context" RETURN n;
MERGE (n:Variable {id: "variable-clean_scope-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "clean_scope", n.file_path = ".\\helpers.py", n.location = "{\"line\": 100, \"column\": 8, \"end_line\": 100, \"end_column\": 19}", n.code_scope = "clean_scope" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 101, \"column\": 8, \"end_line\": 101, \"end_column\": 15}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 107, \"column\": 8, \"end_line\": 107, \"end_column\": 15}", n.code_scope = "node_id" RETURN n;
MERGE (n:Function {id: "function-create_node-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "create_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 111, \"column\": 0, \"end_line\": 127, \"end_column\": 15}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def create_node(node_type, name, file_path=None, metadata=None):\n    \\\"\\\"\\\"Create a node with the given parameters\\\"\\\"\\\"\n    if metadata is None:\n        metadata = {}\n    \n    location = metadata.get('location')\n    node_id = generate_meaningful_id(node_type, name, file_path, location)\n    \n    node = {\n        'id': node_id,\n        'type': node_type,\n        'name': name,\n        'file_path': file_path,\n        **metadata\n    }\n    \n    return node" RETURN n;
MERGE (n:Variable {id: "variable-metadata-create_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "metadata", n.file_path = ".\\helpers.py", n.location = "{\"line\": 114, \"column\": 8, \"end_line\": 114, \"end_column\": 16}", n.code_scope = "metadata" RETURN n;
MERGE (n:Variable {id: "variable-location-create_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "location", n.file_path = ".\\helpers.py", n.location = "{\"line\": 116, \"column\": 4, \"end_line\": 116, \"end_column\": 12}", n.code_scope = "location" RETURN n;
MERGE (n:Variable {id: "variable-node_id-create_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_id", n.file_path = ".\\helpers.py", n.location = "{\"line\": 117, \"column\": 4, \"end_line\": 117, \"end_column\": 11}", n.code_scope = "node_id" RETURN n;
MERGE (n:Variable {id: "variable-node-create_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 119, \"column\": 4, \"end_line\": 119, \"end_column\": 8}", n.code_scope = "node" RETURN n;
MERGE (n:Function {id: "function-create_relationship-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "create_relationship", n.file_path = ".\\helpers.py", n.location = "{\"line\": 129, \"column\": 0, \"end_line\": 142, \"end_column\": 23}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def create_relationship(source_id, target_id, rel_type, metadata=None):\n    \\\"\\\"\\\"Create a relationship between two nodes\\\"\\\"\\\"\n    if metadata is None:\n        metadata = {}\n    \n    relationship = {\n        'id': f\\\"{source_id}-{rel_type}-{target_id}\\\",\n        'source': source_id,\n        'target': target_id,\n        'type': rel_type,\n        **metadata\n    }\n    \n    return relationship" RETURN n;
MERGE (n:Variable {id: "variable-metadata-create_relationship-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "metadata", n.file_path = ".\\helpers.py", n.location = "{\"line\": 132, \"column\": 8, \"end_line\": 132, \"end_column\": 16}", n.code_scope = "metadata" RETURN n;
MERGE (n:Variable {id: "variable-relationship-create_relationship-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\helpers.py", n.location = "{\"line\": 134, \"column\": 4, \"end_line\": 134, \"end_column\": 16}", n.code_scope = "relationship" RETURN n;
MERGE (n:Function {id: "function-register_content-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "register_content", n.file_path = ".\\helpers.py", n.location = "{\"line\": 144, \"column\": 0, \"end_line\": 164, \"end_column\": 34}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def register_content(node_type, name, content, config):\n    \\\"\\\"\\\"Register content for a node if capture_content is enabled\\\"\\\"\\\"\n    if not config.get('capture_content'):\n        return\n    \n    registry = None\n    if node_type == NODE_TYPES['FOLDER']:\n        registry = content_registry['folder_contents']\n    elif node_type == NODE_TYPES['FILE']:\n        registry = content_registry['file_contents']\n    elif node_type == NODE_TYPES['CLASS']:\n        registry = content_registry['class_scopes']\n    elif node_type == NODE_TYPES['METHOD']:\n        registry = content_registry['method_scopes']\n    else:\n        return\n    \n    if name in registry:\n        registry[name].append(content)\n    else:\n        registry[name] = [content]" RETURN n;
MERGE (n:Variable {id: "variable-registry-register_content-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 149, \"column\": 4, \"end_line\": 149, \"end_column\": 12}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-register_content-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 151, \"column\": 8, \"end_line\": 151, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-register_content-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 153, \"column\": 8, \"end_line\": 153, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-register_content-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 155, \"column\": 8, \"end_line\": 155, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Variable {id: "variable-registry-register_content-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "registry", n.file_path = ".\\helpers.py", n.location = "{\"line\": 157, \"column\": 8, \"end_line\": 157, \"end_column\": 16}", n.code_scope = "registry" RETURN n;
MERGE (n:Function {id: "function-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "extract_source_code", n.file_path = ".\\helpers.py", n.location = "{\"line\": 166, \"column\": 0, \"end_line\": 199, \"end_column\": 17}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def extract_source_code(source_code, location):\n    \\\"\\\"\\\"Extract source code from location information\\\"\\\"\\\"\n    if not source_code or not location:\n        return ''\n    \n    try:\n        lines = source_code.split('\\\\n')\n        start_line = location.get('lineno', 1) - 1\n        end_line = location.get('end_lineno', start_line + 1) - 1\n        \n        if start_line == end_line:\n            col_offset = location.get('col_offset', 0)\n            end_col_offset = location.get('end_col_offset', len(lines[start_line]))\n            return lines[start_line][col_offset:end_col_offset]\n        else:\n            code_lines = []\n            # First line from start column to end\n            col_offset = location.get('col_offset', 0)\n            code_lines.append(lines[start_line][col_offset:])\n            \n            # Middle lines (if any)\n            for i in range(start_line + 1, end_line):\n                if i < len(lines):\n                    code_lines.append(lines[i])\n            \n            # Last line from beginning to end column\n            if end_line < len(lines):\n                end_col_offset = location.get('end_col_offset', len(lines[end_line]))\n                code_lines.append(lines[end_line][:end_col_offset])\n            \n            return '\\\\n'.join(code_lines)\n    except Exception as e:\n        print(f\\\"Error extracting source code: {e}\\\")\n        return ''" RETURN n;
MERGE (n:Variable {id: "variable-lines-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "lines", n.file_path = ".\\helpers.py", n.location = "{\"line\": 172, \"column\": 8, \"end_line\": 172, \"end_column\": 13}", n.code_scope = "lines" RETURN n;
MERGE (n:Variable {id: "variable-start_line-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "start_line", n.file_path = ".\\helpers.py", n.location = "{\"line\": 173, \"column\": 8, \"end_line\": 173, \"end_column\": 18}", n.code_scope = "start_line" RETURN n;
MERGE (n:Variable {id: "variable-end_line-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "end_line", n.file_path = ".\\helpers.py", n.location = "{\"line\": 174, \"column\": 8, \"end_line\": 174, \"end_column\": 16}", n.code_scope = "end_line" RETURN n;
MERGE (n:Variable {id: "variable-col_offset-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "col_offset", n.file_path = ".\\helpers.py", n.location = "{\"line\": 177, \"column\": 12, \"end_line\": 177, \"end_column\": 22}", n.code_scope = "col_offset" RETURN n;
MERGE (n:Variable {id: "variable-end_col_offset-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "end_col_offset", n.file_path = ".\\helpers.py", n.location = "{\"line\": 178, \"column\": 12, \"end_line\": 178, \"end_column\": 26}", n.code_scope = "end_col_offset" RETURN n;
MERGE (n:Variable {id: "variable-code_lines-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "code_lines", n.file_path = ".\\helpers.py", n.location = "{\"line\": 181, \"column\": 12, \"end_line\": 181, \"end_column\": 22}", n.code_scope = "code_lines" RETURN n;
MERGE (n:Variable {id: "variable-col_offset-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "col_offset", n.file_path = ".\\helpers.py", n.location = "{\"line\": 183, \"column\": 12, \"end_line\": 183, \"end_column\": 22}", n.code_scope = "col_offset" RETURN n;
MERGE (n:Variable {id: "variable-end_col_offset-extract_source_code-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "end_col_offset", n.file_path = ".\\helpers.py", n.location = "{\"line\": 193, \"column\": 16, \"end_line\": 193, \"end_column\": 30}", n.code_scope = "end_col_offset" RETURN n;
MERGE (n:Function {id: "function-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "get_or_create_folder_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 201, \"column\": 0, \"end_line\": 250, \"end_column\": 15}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def get_or_create_folder_node(folder_path, graph, config):\n    \\\"\\\"\\\"Get or create a folder node\\\"\\\"\\\"\n    if folder_path in node_registry['folder_nodes']:\n        return node_registry['folder_nodes'][folder_path]\n    \n    folder_name = os.path.basename(folder_path) or folder_path\n    node = create_node(NODE_TYPES['FOLDER'], folder_name, folder_path)\n    graph['nodes'].append(node)\n    node_registry['folder_nodes'][folder_path] = node\n    \n    # Create relationship with parent folder\n    parent_path = os.path.dirname(folder_path)\n    if parent_path != folder_path and parent_path:\n        parent_node = get_or_create_folder_node(parent_path, graph, config)\n        relationship = create_relationship(parent_node['id'], node['id'], REL_TYPES['CONTAINS'])\n        graph['relationships'].append(relationship)\n    \n    # Register folder content if config allows\n    if config.get('capture_content'):\n        try:\n            if os.path.exists(folder_path):\n                items = os.listdir(folder_path)\n                folder_content = []\n                for item in items:\n                    item_path = os.path.join(folder_path, item)\n                    if os.path.isdir(item_path):\n                        folder_content.append({\n                            'name': item,\n                            'type': 'folder',\n                            'size': 0,\n                            'last_modified': os.path.getmtime(item_path)\n                        })\n                    else:\n                        folder_content.append({\n                            'name': item,\n                            'type': 'file',\n                            'size': os.path.getsize(item_path),\n                            'last_modified': os.path.getmtime(item_path)\n                        })\n                \n                folders = len([f for f in folder_content if f['type'] == 'folder'])\n                files = len([f for f in folder_content if f['type'] == 'file'])\n                node['content_count'] = len(folder_content)\n                node['content_summary'] = f\\\"{folders} folders, {files} files\\\"\n                \n                register_content(NODE_TYPES['FOLDER'], folder_name, folder_content, config)\n        except Exception as e:\n            print(f\\\"Error reading folder contents for {folder_path}: {e}\\\")\n    \n    return node" RETURN n;
MERGE (n:Variable {id: "variable-folder_name-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "folder_name", n.file_path = ".\\helpers.py", n.location = "{\"line\": 206, \"column\": 4, \"end_line\": 206, \"end_column\": 15}", n.code_scope = "folder_name" RETURN n;
MERGE (n:Variable {id: "variable-node-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 207, \"column\": 4, \"end_line\": 207, \"end_column\": 8}", n.code_scope = "node" RETURN n;
MERGE (n:Variable {id: "variable-parent_path-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "parent_path", n.file_path = ".\\helpers.py", n.location = "{\"line\": 212, \"column\": 4, \"end_line\": 212, \"end_column\": 15}", n.code_scope = "parent_path" RETURN n;
MERGE (n:Variable {id: "variable-parent_node-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "parent_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 214, \"column\": 8, \"end_line\": 214, \"end_column\": 19}", n.code_scope = "parent_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\helpers.py", n.location = "{\"line\": 215, \"column\": 8, \"end_line\": 215, \"end_column\": 20}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-items-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "items", n.file_path = ".\\helpers.py", n.location = "{\"line\": 222, \"column\": 16, \"end_line\": 222, \"end_column\": 21}", n.code_scope = "items" RETURN n;
MERGE (n:Variable {id: "variable-folder_content-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "folder_content", n.file_path = ".\\helpers.py", n.location = "{\"line\": 223, \"column\": 16, \"end_line\": 223, \"end_column\": 30}", n.code_scope = "folder_content" RETURN n;
MERGE (n:Variable {id: "variable-item_path-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "item_path", n.file_path = ".\\helpers.py", n.location = "{\"line\": 225, \"column\": 20, \"end_line\": 225, \"end_column\": 29}", n.code_scope = "item_path" RETURN n;
MERGE (n:Variable {id: "variable-folders-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "folders", n.file_path = ".\\helpers.py", n.location = "{\"line\": 241, \"column\": 16, \"end_line\": 241, \"end_column\": 23}", n.code_scope = "folders" RETURN n;
MERGE (n:Variable {id: "variable-files-get_or_create_folder_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "files", n.file_path = ".\\helpers.py", n.location = "{\"line\": 242, \"column\": 16, \"end_line\": 242, \"end_column\": 21}", n.code_scope = "files" RETURN n;
MERGE (n:Function {id: "function-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "get_or_create_file_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 252, \"column\": 0, \"end_line\": 281, \"end_column\": 15}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def get_or_create_file_node(file_path, graph, config):\n    \\\"\\\"\\\"Get or create a file node\\\"\\\"\\\"\n    if file_path in node_registry['file_nodes']:\n        return node_registry['file_nodes'][file_path]\n    \n    filename = os.path.basename(file_path)\n    node = create_node(NODE_TYPES['FILE'], filename, file_path)\n    graph['nodes'].append(node)\n    node_registry['file_nodes'][file_path] = node\n    \n    # Create relationship with containing folder\n    folder_path = os.path.dirname(file_path)\n    folder_node = get_or_create_folder_node(folder_path, graph, config)\n    relationship = create_relationship(folder_node['id'], node['id'], REL_TYPES['CONTAINS'])\n    graph['relationships'].append(relationship)\n    \n    # Register file content if config allows\n    if config.get('capture_content'):\n        try:\n            if os.path.exists(file_path):\n                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                    file_content = f.read()\n                    node['file_size'] = len(file_content)\n                    node['line_count'] = len(file_content.split('\\\\n'))\n                    \n                    register_content(NODE_TYPES['FILE'], filename, file_content, config)\n        except Exception as e:\n            print(f\\\"Error reading file content for {file_path}: {e}\\\")\n    \n    return node" RETURN n;
MERGE (n:Variable {id: "variable-filename-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "filename", n.file_path = ".\\helpers.py", n.location = "{\"line\": 257, \"column\": 4, \"end_line\": 257, \"end_column\": 12}", n.code_scope = "filename" RETURN n;
MERGE (n:Variable {id: "variable-node-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 258, \"column\": 4, \"end_line\": 258, \"end_column\": 8}", n.code_scope = "node" RETURN n;
MERGE (n:Variable {id: "variable-folder_path-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "folder_path", n.file_path = ".\\helpers.py", n.location = "{\"line\": 263, \"column\": 4, \"end_line\": 263, \"end_column\": 15}", n.code_scope = "folder_path" RETURN n;
MERGE (n:Variable {id: "variable-folder_node-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "folder_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 264, \"column\": 4, \"end_line\": 264, \"end_column\": 15}", n.code_scope = "folder_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\helpers.py", n.location = "{\"line\": 265, \"column\": 4, \"end_line\": 265, \"end_column\": 16}", n.code_scope = "relationship" RETURN n;
MERGE (n:Variable {id: "variable-file_content-get_or_create_file_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "file_content", n.file_path = ".\\helpers.py", n.location = "{\"line\": 273, \"column\": 20, \"end_line\": 273, \"end_column\": 32}", n.code_scope = "file_content" RETURN n;
MERGE (n:Function {id: "function-create_entity_node-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "create_entity_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 283, \"column\": 0, \"end_line\": 335, \"end_column\": 15}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def create_entity_node(node_type, name, file_path, location, metadata, source_code, graph, config):\n    \\\"\\\"\\\"Create an entity node (class, method, function, variable, etc.)\\\"\\\"\\\"\n    # Check if this type of node should be included based on configuration\n    if (\n        (node_type == NODE_TYPES['VARIABLE'] and not config.get('include_variables')) or\n        (node_type == NODE_TYPES['IMPORT'] and not config.get('include_imports')) or\n        (node_type == NODE_TYPES['CLASS'] and not config.get('include_classes')) or\n        (node_type == NODE_TYPES['METHOD'] and not config.get('include_methods')) or\n        (node_type == NODE_TYPES['FUNCTION'] and not config.get('include_functions'))\n    ):\n        # Return a placeholder id for tracking in scope but not in actual graph\n        return f\\\"placeholder_{node_type}_{name}\\\"\n    \n    key = f\\\"{file_path}:{node_type}:{name}:{location.get('lineno', 0)}:{location.get('col_offset', 0)}\\\"\n    \n    if key in node_registry['entity_nodes']:\n        return node_registry['entity_nodes'][key]\n    \n    # Add code scope content if provided\n    if config.get('capture_content') and source_code:\n        code_content = extract_source_code(source_code, location)\n        if code_content:\n            metadata['code_scope'] = code_content\n            \n            # Register content in appropriate registry\n            if node_type in [NODE_TYPES['CLASS'], NODE_TYPES['METHOD']]:\n                register_content(node_type, name, code_content, config)\n    \n    node = create_node(node_type, name, file_path, {\n        'location': {\n            'line': location.get('lineno', 0),\n            'column': location.get('col_offset', 0),\n            'end_line': location.get('end_lineno', 0),\n            'end_column': location.get('end_col_offset', 0)\n        },\n        **metadata\n    })\n    \n    graph['nodes'].append(node)\n    node_registry['entity_nodes'][key] = node\n    \n    # Create relationship with containing file\n    file_node = get_or_create_file_node(file_path, graph, config)\n    relationship = create_relationship(file_node['id'], node['id'], REL_TYPES['CONTAINS'])\n    graph['relationships'].append(relationship)\n    \n    # Update global tracking for class and method contexts\n    if node_type == NODE_TYPES['CLASS']:\n        global_context['current_class_node'] = node['id']\n    elif node_type == NODE_TYPES['METHOD']:\n        global_context['current_method_node'] = node['id']\n    \n    return node" RETURN n;
MERGE (n:Variable {id: "variable-key-create_entity_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "key", n.file_path = ".\\helpers.py", n.location = "{\"line\": 296, \"column\": 4, \"end_line\": 296, \"end_column\": 7}", n.code_scope = "key" RETURN n;
MERGE (n:Variable {id: "variable-code_content-create_entity_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "code_content", n.file_path = ".\\helpers.py", n.location = "{\"line\": 303, \"column\": 8, \"end_line\": 303, \"end_column\": 20}", n.code_scope = "code_content" RETURN n;
MERGE (n:Variable {id: "variable-node-create_entity_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 311, \"column\": 4, \"end_line\": 311, \"end_column\": 8}", n.code_scope = "node" RETURN n;
MERGE (n:Variable {id: "variable-file_node-create_entity_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "file_node", n.file_path = ".\\helpers.py", n.location = "{\"line\": 325, \"column\": 4, \"end_line\": 325, \"end_column\": 13}", n.code_scope = "file_node" RETURN n;
MERGE (n:Variable {id: "variable-relationship-create_entity_node-helpers-L0"}) ON CREATE SET n.type = "Variable", n.name = "relationship", n.file_path = ".\\helpers.py", n.location = "{\"line\": 326, \"column\": 4, \"end_line\": 326, \"end_column\": 16}", n.code_scope = "relationship" RETURN n;
MERGE (n:Function {id: "function-clear_registries-helpers-L0"}) ON CREATE SET n.type = "Function", n.name = "clear_registries", n.file_path = ".\\helpers.py", n.location = "{\"line\": 337, \"column\": 0, \"end_line\": 354, \"end_column\": 48}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def clear_registries():\n    \\\"\\\"\\\"Clear all registries for a fresh start\\\"\\\"\\\"\n    node_registry['folder_nodes'].clear()\n    node_registry['file_nodes'].clear()\n    node_registry['entity_nodes'].clear()\n    \n    content_registry['folder_contents'].clear()\n    content_registry['file_contents'].clear()\n    content_registry['class_scopes'].clear()\n    content_registry['method_scopes'].clear()\n    \n    external_libraries.clear()\n    \n    global_context['current_class_context'] = None\n    global_context['current_method_context'] = None\n    global_context['current_scope_context'] = None\n    global_context['current_class_node'] = None\n    global_context['current_method_node'] = None" RETURN n;
MERGE (n:File {id: "file-main.py-bWFpbi5w"}) ON CREATE SET n.type = "File", n.name = "main.py", n.file_path = ".\\main.py", n.file_size = 6852, n.line_count = 152, n.content_lists = ["#!/usr/bin/env python3\n\"\"\"\nPython Code Indexer - Main Entry Point\nAnalyzes Python code and generates Neo4j Cypher import statements\n\"\"\"\nimport sys\nimport os\nimport argparse\nimport time\nfrom scanner import scan_python_service\nfrom exporters import export_to_json, export_to_neo4j\nfrom constants import DEFAULT_CONFIG, NODE_TYPES\n\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description='Analyze Python code and generate Neo4j import')\n    parser.add_argument('root_path', nargs='?', default='./src', \n                       help='Root directory of your Python service (default: ./src)')\n    parser.add_argument('--include-variables', action='store_true', default=False,\n                       help='Include variable nodes in the graph')\n    parser.add_argument('--include-imports', action='store_true', default=True,\n                       help='Include import nodes in the graph')\n    parser.add_argument('--include-folders', action='store_true', default=True,\n                       help='Include folder nodes in the graph')\n    parser.add_argument('--include-files', action='store_true', default=True,\n                       help='Include file nodes in the graph')\n    parser.add_argument('--include-classes', action='store_true', default=True,\n                       help='Include class nodes in the graph')\n    parser.add_argument('--include-methods', action='store_true', default=True,\n                       help='Include method nodes in the graph')\n    parser.add_argument('--include-functions', action='store_true', default=True,\n                       help='Include function nodes in the graph')\n    parser.add_argument('--ignore-venv', action='store_true', default=True,\n                       help='Ignore virtual environment directories')\n    parser.add_argument('--track-external-libraries', action='store_true', default=False,\n                       help='Track external library imports')\n    parser.add_argument('--capture-content', action='store_true', default=True,\n                       help='Capture code content for nodes')\n    parser.add_argument('--output-json', default='./graph-data.json',\n                       help='Output JSON file path')\n    parser.add_argument('--output-cypher', default='./neo4j-import.cypher',\n                       help='Output Cypher file path')\n    \n    return parser.parse_args()\n\ndef main():\n    args = parse_arguments()\n    \n    # Build config from arguments\n    config = {\n        'include_variables': args.include_variables,\n        'include_imports': args.include_imports,\n        'include_folders': args.include_folders,\n        'include_files': args.include_files,\n        'include_classes': args.include_classes,\n        'include_methods': args.include_methods,\n        'include_functions': args.include_functions,\n        'ignore_venv': args.ignore_venv,\n        'track_external_libraries': args.track_external_libraries,\n        'capture_content': args.capture_content\n    }\n    \n    print(f\"Starting scan of Python service at: {args.root_path}\")\n    print(f\"Configuration: {config}\")\n    \n    # Scan the service and build the graph\n    start_time = time.time()\n    graph = scan_python_service(args.root_path, config)\n    end_time = time.time()\n    \n    print(f\"Scan completed in {end_time - start_time:.2f} seconds\")\n    \n    # Log some stats\n    print(f\"\\nGraph Statistics:\")\n    print(f\"- Nodes: {len(graph['nodes'])}\")\n    print(f\"- Relationships: {len(graph['relationships'])}\")\n    print(f\"- Node types: {len(set(node['type'] for node in graph['nodes']))}\")\n    print(f\"- Relationship types: {len(set(rel['type'] for rel in graph['relationships']))}\")\n    \n    # Count by node type with ID examples\n    node_type_count = {}\n    for node in graph['nodes']:\n        node_type = node['type']\n        if node_type not in node_type_count:\n            node_type_count[node_type] = {'count': 0, 'examples': []}\n        \n        node_type_count[node_type]['count'] += 1\n        \n        # Store some example IDs for debugging\n        if len(node_type_count[node_type]['examples']) < 3:\n            node_type_count[node_type]['examples'].append(node['id'])\n    \n    print('\\nNode count by type:')\n    for node_type, data in node_type_count.items():\n        print(f\"- {node_type}: {data['count']}\")\n        print(f\"  Example IDs: {', '.join(data['examples'])}\")\n    \n    # Count external libraries\n    external_libraries = [node for node in graph['nodes'] if node['type'] == NODE_TYPES['EXTERNAL_LIBRARY']]\n    print(f\"\\nExternal libraries: {len(external_libraries)}\")\n    \n    if external_libraries:\n        print('Top external libraries by number of imports:')\n        \n        # Count imports per library\n        lib_import_counts = {}\n        for rel in graph['relationships']:\n            if rel['type'] == 'IMPORTS':\n                target_node = next((n for n in graph['nodes'] if n['id'] == rel['target']), None)\n                if target_node and target_node['type'] == NODE_TYPES['EXTERNAL_LIBRARY']:\n                    lib_name = target_node['name']\n                    lib_import_counts[lib_name] = lib_import_counts.get(lib_name, 0) + 1\n        \n        # Display top 10 most imported libraries\n        sorted_libs = sorted(lib_import_counts.items(), key=lambda x: x[1], reverse=True)[:10]\n        for lib_name, count in sorted_libs:\n            print(f\"- {lib_name}: {count} imports\")\n    \n    # Analyze relationship consistency\n    print('\\nRelationship validation:')\n    node_ids = set(node['id'] for node in graph['nodes'])\n    bad_relationships = []\n    \n    for rel in graph['relationships']:\n        source_exists = rel['source'] in node_ids\n        target_exists = rel['target'] in node_ids\n        if not source_exists or not target_exists:\n            bad_relationships.append(rel)\n    \n    print(f\"- Total relationships: {len(graph['relationships'])}\")\n    print(f\"- Valid relationships: {len(graph['relationships']) - len(bad_relationships)}\")\n    print(f\"- Invalid relationships: {len(bad_relationships)}\")\n    \n    if bad_relationships:\n        print('\\nSample of invalid relationships:')\n        for rel in bad_relationships[:3]:\n            print(f\"- ID: {rel['id']}\")\n            print(f\"  Source: {rel['source']} ({'exists' if rel['source'] in node_ids else 'missing'})\")\n            print(f\"  Target: {rel['target']} ({'exists' if rel['target'] in node_ids else 'missing'})\")\n            print(f\"  Type: {rel['type']}\")\n    \n    # Export the graph to JSON\n    export_to_json(graph, args.output_json)\n    print(f\"\\nGraph data exported to {args.output_json}\")\n    \n    # Generate Neo4j Cypher statements\n    cypher = export_to_neo4j(graph, config)\n    with open(args.output_cypher, 'w', encoding='utf-8') as f:\n        f.write(cypher)\n    print(f\"Neo4j Cypher statements written to {args.output_cypher}\")\n\nif __name__ == '__main__':\n    main() "] RETURN n;
MERGE (n:Import {id: "import-sys"}) ON CREATE SET n.type = "Import", n.name = "sys", n.file_path = ".\\main.py", n.location = "{\"line\": 6, \"column\": 0, \"end_line\": 6, \"end_column\": 10}", n.as_name = "sys", n.code_scope = "import sys" RETURN n;
MERGE (n:Import {id: "import-os"}) ON CREATE SET n.type = "Import", n.name = "os", n.file_path = ".\\main.py", n.location = "{\"line\": 7, \"column\": 0, \"end_line\": 7, \"end_column\": 9}", n.as_name = "os", n.code_scope = "import os" RETURN n;
MERGE (n:Import {id: "import-argparse"}) ON CREATE SET n.type = "Import", n.name = "argparse", n.file_path = ".\\main.py", n.location = "{\"line\": 8, \"column\": 0, \"end_line\": 8, \"end_column\": 15}", n.as_name = "argparse", n.code_scope = "import argparse" RETURN n;
MERGE (n:Import {id: "import-time"}) ON CREATE SET n.type = "Import", n.name = "time", n.file_path = ".\\main.py", n.location = "{\"line\": 9, \"column\": 0, \"end_line\": 9, \"end_column\": 11}", n.as_name = "time", n.code_scope = "import time" RETURN n;
MERGE (n:ExternalLibrary {id: "lib-scanner"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "scanner", n.is_external = true, n.original_import = "scanner" RETURN n;
MERGE (n:ExternalLibrary {id: "lib-exporters"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "exporters", n.is_external = true, n.original_import = "exporters" RETURN n;
MERGE (n:Function {id: "function-parse_arguments-main-L0"}) ON CREATE SET n.type = "Function", n.name = "parse_arguments", n.file_path = ".\\main.py", n.location = "{\"line\": 14, \"column\": 0, \"end_line\": 43, \"end_column\": 30}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def parse_arguments():\n    parser = argparse.ArgumentParser(description='Analyze Python code and generate Neo4j import')\n    parser.add_argument('root_path', nargs='?', default='./src', \n                       help='Root directory of your Python service (default: ./src)')\n    parser.add_argument('--include-variables', action='store_true', default=False,\n                       help='Include variable nodes in the graph')\n    parser.add_argument('--include-imports', action='store_true', default=True,\n                       help='Include import nodes in the graph')\n    parser.add_argument('--include-folders', action='store_true', default=True,\n                       help='Include folder nodes in the graph')\n    parser.add_argument('--include-files', action='store_true', default=True,\n                       help='Include file nodes in the graph')\n    parser.add_argument('--include-classes', action='store_true', default=True,\n                       help='Include class nodes in the graph')\n    parser.add_argument('--include-methods', action='store_true', default=True,\n                       help='Include method nodes in the graph')\n    parser.add_argument('--include-functions', action='store_true', default=True,\n                       help='Include function nodes in the graph')\n    parser.add_argument('--ignore-venv', action='store_true', default=True,\n                       help='Ignore virtual environment directories')\n    parser.add_argument('--track-external-libraries', action='store_true', default=False,\n                       help='Track external library imports')\n    parser.add_argument('--capture-content', action='store_true', default=True,\n                       help='Capture code content for nodes')\n    parser.add_argument('--output-json', default='./graph-data.json',\n                       help='Output JSON file path')\n    parser.add_argument('--output-cypher', default='./neo4j-import.cypher',\n                       help='Output Cypher file path')\n    \n    return parser.parse_args()" RETURN n;
MERGE (n:Variable {id: "variable-parser-parse_arguments-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "parser", n.file_path = ".\\main.py", n.location = "{\"line\": 15, \"column\": 4, \"end_line\": 15, \"end_column\": 10}", n.code_scope = "parser" RETURN n;
MERGE (n:Function {id: "function-main-main-L0"}) ON CREATE SET n.type = "Function", n.name = "main", n.file_path = ".\\main.py", n.location = "{\"line\": 45, \"column\": 0, \"end_line\": 149, \"end_column\": 69}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def main():\n    args = parse_arguments()\n    \n    # Build config from arguments\n    config = {\n        'include_variables': args.include_variables,\n        'include_imports': args.include_imports,\n        'include_folders': args.include_folders,\n        'include_files': args.include_files,\n        'include_classes': args.include_classes,\n        'include_methods': args.include_methods,\n        'include_functions': args.include_functions,\n        'ignore_venv': args.ignore_venv,\n        'track_external_libraries': args.track_external_libraries,\n        'capture_content': args.capture_content\n    }\n    \n    print(f\\\"Starting scan of Python service at: {args.root_path}\\\")\n    print(f\\\"Configuration: {config}\\\")\n    \n    # Scan the service and build the graph\n    start_time = time.time()\n    graph = scan_python_service(args.root_path, config)\n    end_time = time.time()\n    \n    print(f\\\"Scan completed in {end_time - start_time:.2f} seconds\\\")\n    \n    # Log some stats\n    print(f\\\"\\\\nGraph Statistics:\\\")\n    print(f\\\"- Nodes: {len(graph['nodes'])}\\\")\n    print(f\\\"- Relationships: {len(graph['relationships'])}\\\")\n    print(f\\\"- Node types: {len(set(node['type'] for node in graph['nodes']))}\\\")\n    print(f\\\"- Relationship types: {len(set(rel['type'] for rel in graph['relationships']))}\\\")\n    \n    # Count by node type with ID examples\n    node_type_count = {}\n    for node in graph['nodes']:\n        node_type = node['type']\n        if node_type not in node_type_count:\n            node_type_count[node_type] = {'count': 0, 'examples': []}\n        \n        node_type_count[node_type]['count'] += 1\n        \n        # Store some example IDs for debugging\n        if len(node_type_count[node_type]['examples']) < 3:\n            node_type_count[node_type]['examples'].append(node['id'])\n    \n    print('\\\\nNode count by type:')\n    for node_type, data in node_type_count.items():\n        print(f\\\"- {node_type}: {data['count']}\\\")\n        print(f\\\"  Example IDs: {', '.join(data['examples'])}\\\")\n    \n    # Count external libraries\n    external_libraries = [node for node in graph['nodes'] if node['type'] == NODE_TYPES['EXTERNAL_LIBRARY']]\n    print(f\\\"\\\\nExternal libraries: {len(external_libraries)}\\\")\n    \n    if external_libraries:\n        print('Top external libraries by number of imports:')\n        \n        # Count imports per library\n        lib_import_counts = {}\n        for rel in graph['relationships']:\n            if rel['type'] == 'IMPORTS':\n                target_node = next((n for n in graph['nodes'] if n['id'] == rel['target']), None)\n                if target_node and target_node['type'] == NODE_TYPES['EXTERNAL_LIBRARY']:\n                    lib_name = target_node['name']\n                    lib_import_counts[lib_name] = lib_import_counts.get(lib_name, 0) + 1\n        \n        # Display top 10 most imported libraries\n        sorted_libs = sorted(lib_import_counts.items(), key=lambda x: x[1], reverse=True)[:10]\n        for lib_name, count in sorted_libs:\n            print(f\\\"- {lib_name}: {count} imports\\\")\n    \n    # Analyze relationship consistency\n    print('\\\\nRelationship validation:')\n    node_ids = set(node['id'] for node in graph['nodes'])\n    bad_relationships = []\n    \n    for rel in graph['relationships']:\n        source_exists = rel['source'] in node_ids\n        target_exists = rel['target'] in node_ids\n        if not source_exists or not target_exists:\n            bad_relationships.append(rel)\n    \n    print(f\\\"- Total relationships: {len(graph['relationships'])}\\\")\n    print(f\\\"- Valid relationships: {len(graph['relationships']) - len(bad_relationships)}\\\")\n    print(f\\\"- Invalid relationships: {len(bad_relationships)}\\\")\n    \n    if bad_relationships:\n        print('\\\\nSample of invalid relationships:')\n        for rel in bad_relationships[:3]:\n            print(f\\\"- ID: {rel['id']}\\\")\n            print(f\\\"  Source: {rel['source']} ({'exists' if rel['source'] in node_ids else 'missing'})\\\")\n            print(f\\\"  Target: {rel['target']} ({'exists' if rel['target'] in node_ids else 'missing'})\\\")\n            print(f\\\"  Type: {rel['type']}\\\")\n    \n    # Export the graph to JSON\n    export_to_json(graph, args.output_json)\n    print(f\\\"\\\\nGraph data exported to {args.output_json}\\\")\n    \n    # Generate Neo4j Cypher statements\n    cypher = export_to_neo4j(graph, config)\n    with open(args.output_cypher, 'w', encoding='utf-8') as f:\n        f.write(cypher)\n    print(f\\\"Neo4j Cypher statements written to {args.output_cypher}\\\")" RETURN n;
MERGE (n:Variable {id: "variable-args-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "args", n.file_path = ".\\main.py", n.location = "{\"line\": 46, \"column\": 4, \"end_line\": 46, \"end_column\": 8}", n.code_scope = "args" RETURN n;
MERGE (n:Variable {id: "variable-config-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "config", n.file_path = ".\\main.py", n.location = "{\"line\": 49, \"column\": 4, \"end_line\": 49, \"end_column\": 10}", n.code_scope = "config" RETURN n;
MERGE (n:Variable {id: "variable-start_time-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "start_time", n.file_path = ".\\main.py", n.location = "{\"line\": 66, \"column\": 4, \"end_line\": 66, \"end_column\": 14}", n.code_scope = "start_time" RETURN n;
MERGE (n:Variable {id: "variable-graph-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "graph", n.file_path = ".\\main.py", n.location = "{\"line\": 67, \"column\": 4, \"end_line\": 67, \"end_column\": 9}", n.code_scope = "graph" RETURN n;
MERGE (n:Variable {id: "variable-end_time-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "end_time", n.file_path = ".\\main.py", n.location = "{\"line\": 68, \"column\": 4, \"end_line\": 68, \"end_column\": 12}", n.code_scope = "end_time" RETURN n;
MERGE (n:Variable {id: "variable-node_type_count-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_type_count", n.file_path = ".\\main.py", n.location = "{\"line\": 80, \"column\": 4, \"end_line\": 80, \"end_column\": 19}", n.code_scope = "node_type_count" RETURN n;
MERGE (n:Variable {id: "variable-node_type-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_type", n.file_path = ".\\main.py", n.location = "{\"line\": 82, \"column\": 8, \"end_line\": 82, \"end_column\": 17}", n.code_scope = "node_type" RETURN n;
MERGE (n:Variable {id: "variable-external_libraries-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "external_libraries", n.file_path = ".\\main.py", n.location = "{\"line\": 98, \"column\": 4, \"end_line\": 98, \"end_column\": 22}", n.code_scope = "external_libraries" RETURN n;
MERGE (n:Variable {id: "variable-lib_import_counts-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "lib_import_counts", n.file_path = ".\\main.py", n.location = "{\"line\": 105, \"column\": 8, \"end_line\": 105, \"end_column\": 25}", n.code_scope = "lib_import_counts" RETURN n;
MERGE (n:Variable {id: "variable-target_node-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "target_node", n.file_path = ".\\main.py", n.location = "{\"line\": 108, \"column\": 16, \"end_line\": 108, \"end_column\": 27}", n.code_scope = "target_node" RETURN n;
MERGE (n:Variable {id: "variable-lib_name-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "lib_name", n.file_path = ".\\main.py", n.location = "{\"line\": 110, \"column\": 20, \"end_line\": 110, \"end_column\": 28}", n.code_scope = "lib_name" RETURN n;
MERGE (n:Variable {id: "variable-sorted_libs-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "sorted_libs", n.file_path = ".\\main.py", n.location = "{\"line\": 114, \"column\": 8, \"end_line\": 114, \"end_column\": 19}", n.code_scope = "sorted_libs" RETURN n;
MERGE (n:Variable {id: "variable-node_ids-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "node_ids", n.file_path = ".\\main.py", n.location = "{\"line\": 120, \"column\": 4, \"end_line\": 120, \"end_column\": 12}", n.code_scope = "node_ids" RETURN n;
MERGE (n:Variable {id: "variable-bad_relationships-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "bad_relationships", n.file_path = ".\\main.py", n.location = "{\"line\": 121, \"column\": 4, \"end_line\": 121, \"end_column\": 21}", n.code_scope = "bad_relationships" RETURN n;
MERGE (n:Variable {id: "variable-source_exists-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "source_exists", n.file_path = ".\\main.py", n.location = "{\"line\": 124, \"column\": 8, \"end_line\": 124, \"end_column\": 21}", n.code_scope = "source_exists" RETURN n;
MERGE (n:Variable {id: "variable-target_exists-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "target_exists", n.file_path = ".\\main.py", n.location = "{\"line\": 125, \"column\": 8, \"end_line\": 125, \"end_column\": 21}", n.code_scope = "target_exists" RETURN n;
MERGE (n:Variable {id: "variable-cypher-main-main-L0"}) ON CREATE SET n.type = "Variable", n.name = "cypher", n.file_path = ".\\main.py", n.location = "{\"line\": 146, \"column\": 4, \"end_line\": 146, \"end_column\": 10}", n.code_scope = "cypher" RETURN n;
MERGE (n:File {id: "file-scanner.py-c2Nhbm5l"}) ON CREATE SET n.type = "File", n.name = "scanner.py", n.file_path = ".\\scanner.py", n.file_size = 6066, n.line_count = 149, n.content_lists = ["\"\"\"\nPython Scanner Module\nScans directories for Python files and orchestrates the analysis\n\"\"\"\nimport os\nimport json\nfrom pathlib import Path\nfrom constants import NODE_TYPES, VENV_DIRS, PYTHON_EXTENSIONS, DEFAULT_CONFIG\nfrom helpers import get_or_create_folder_node, clear_registries, external_libraries, create_node\nfrom ast_analyzer import analyze_file\n\ndef scan_directory(dir_path, graph, config):\n    \"\"\"Recursively scan a directory for Python files\"\"\"\n    if config.get('ignore_venv') and any(venv_dir in dir_path for venv_dir in VENV_DIRS):\n        return\n    \n    print(f\"Scanning directory: {dir_path}\")\n    \n    try:\n        items = os.listdir(dir_path)\n        for item in items:\n            item_path = os.path.join(dir_path, item)\n            \n            if os.path.isdir(item_path):\n                # Skip virtual environment directories\n                if config.get('ignore_venv') and item in VENV_DIRS:\n                    continue\n                scan_directory(item_path, graph, config)\n            elif os.path.isfile(item_path):\n                # Check if it's a Python file\n                if any(item_path.endswith(ext) for ext in PYTHON_EXTENSIONS):\n                    analyze_file(item_path, graph, config)\n    except PermissionError:\n        print(f\"Permission denied: {dir_path}\")\n    except Exception as e:\n        print(f\"Error scanning directory {dir_path}: {e}\")\n\ndef parse_requirements_file(root_path):\n    \"\"\"Parse requirements.txt or setup.py to identify project dependencies\"\"\"\n    dependencies = {}\n    \n    # Try requirements.txt\n    req_files = ['requirements.txt', 'requirements-dev.txt', 'dev-requirements.txt']\n    for req_file in req_files:\n        req_path = os.path.join(root_path, req_file)\n        if os.path.exists(req_path):\n            try:\n                with open(req_path, 'r', encoding='utf-8') as f:\n                    for line in f:\n                        line = line.strip()\n                        if line and not line.startswith('#') and not line.startswith('-'):\n                            # Parse dependency (handle version specs)\n                            if '==' in line:\n                                name, version = line.split('==', 1)\n                                dependencies[name.strip()] = version.strip()\n                            elif '>=' in line:\n                                name = line.split('>=')[0].strip()\n                                dependencies[name] = 'latest'\n                            elif '>' in line:\n                                name = line.split('>')[0].strip()\n                                dependencies[name] = 'latest'\n                            else:\n                                # Simple package name\n                                dependencies[line] = 'latest'\n            except Exception as e:\n                print(f\"Error parsing {req_file}: {e}\")\n    \n    # Try setup.py (basic parsing)\n    setup_path = os.path.join(root_path, 'setup.py')\n    if os.path.exists(setup_path):\n        try:\n            with open(setup_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                # Look for install_requires or requires\n                import re\n                requires_match = re.search(r'install_requires\\s*=\\s*\\[(.*?)\\]', content, re.DOTALL)\n                if requires_match:\n                    requires_str = requires_match.group(1)\n                    # Extract package names from strings\n                    packages = re.findall(r'[\"\\']([^\"\\'>=<\\s]+)', requires_str)\n                    for pkg in packages:\n                        if pkg not in dependencies:\n                            dependencies[pkg] = 'latest'\n        except Exception as e:\n            print(f\"Error parsing setup.py: {e}\")\n    \n    # Try pyproject.toml (basic parsing)\n    pyproject_path = os.path.join(root_path, 'pyproject.toml')\n    if os.path.exists(pyproject_path):\n        try:\n            with open(pyproject_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                # Look for dependencies in pyproject.toml\n                import re\n                deps_match = re.search(r'dependencies\\s*=\\s*\\[(.*?)\\]', content, re.DOTALL)\n                if deps_match:\n                    deps_str = deps_match.group(1)\n                    packages = re.findall(r'[\"\\']([^\"\\'>=<\\s]+)', deps_str)\n                    for pkg in packages:\n                        if pkg not in dependencies:\n                            dependencies[pkg] = 'latest'\n        except Exception as e:\n            print(f\"Error parsing pyproject.toml: {e}\")\n    \n    return dependencies\n\ndef scan_python_service(root_path, custom_config=None):\n    \"\"\"Main function to scan a Python service/project\"\"\"\n    if custom_config is None:\n        custom_config = {}\n    \n    # Merge with default config\n    config = {**DEFAULT_CONFIG, **custom_config}\n    \n    print(f\"Starting scan of Python service at: {root_path}\")\n    print(f\"Configuration: {json.dumps(config, indent=2)}\")\n    \n    # Initialize graph structure\n    graph = {'nodes': [], 'relationships': []}\n    \n    # Clear previous data\n    clear_registries()\n    \n    # Try to find and parse dependency files\n    try:\n        dependencies = parse_requirements_file(root_path)\n        \n        # Pre-register all dependencies as external libraries\n        for lib_name, version in dependencies.items():\n            node = create_node(NODE_TYPES['EXTERNAL_LIBRARY'], lib_name, None, {\n                'is_external': True,\n                'version': version,\n                'from_requirements': True\n            })\n            graph['nodes'].append(node)\n            external_libraries[lib_name] = node\n        \n        if dependencies:\n            print(f\"Found {len(dependencies)} dependencies in requirements files\")\n    except Exception as e:\n        print(f\"Error parsing dependencies: {e}\")\n    \n    # Initialize root folder\n    get_or_create_folder_node(root_path, graph, config)\n    \n    # Start scanning\n    scan_directory(root_path, graph, config)\n    \n    return graph "] RETURN n;
MERGE (n:Import {id: "import-os"}) ON CREATE SET n.type = "Import", n.name = "os", n.file_path = ".\\scanner.py", n.location = "{\"line\": 5, \"column\": 0, \"end_line\": 5, \"end_column\": 9}", n.as_name = "os", n.code_scope = "import os" RETURN n;
MERGE (n:Import {id: "import-json"}) ON CREATE SET n.type = "Import", n.name = "json", n.file_path = ".\\scanner.py", n.location = "{\"line\": 6, \"column\": 0, \"end_line\": 6, \"end_column\": 11}", n.as_name = "json", n.code_scope = "import json" RETURN n;
MERGE (n:Import {id: "import-pathlib_Path"}) ON CREATE SET n.type = "Import", n.name = "pathlib.Path", n.file_path = ".\\scanner.py", n.location = "{\"line\": 7, \"column\": 0, \"end_line\": 7, \"end_column\": 24}", n.from_module = "pathlib", n.import_name = "Path", n.as_name = "Path", n.code_scope = "from pathlib import Path" RETURN n;
MERGE (n:ExternalLibrary {id: "lib-ast_analyzer"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "ast_analyzer", n.is_external = true, n.original_import = "ast_analyzer" RETURN n;
MERGE (n:Function {id: "function-scan_directory-scanner-L0"}) ON CREATE SET n.type = "Function", n.name = "scan_directory", n.file_path = ".\\scanner.py", n.location = "{\"line\": 12, \"column\": 0, \"end_line\": 36, \"end_column\": 58}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def scan_directory(dir_path, graph, config):\n    \\\"\\\"\\\"Recursively scan a directory for Python files\\\"\\\"\\\"\n    if config.get('ignore_venv') and any(venv_dir in dir_path for venv_dir in VENV_DIRS):\n        return\n    \n    print(f\\\"Scanning directory: {dir_path}\\\")\n    \n    try:\n        items = os.listdir(dir_path)\n        for item in items:\n            item_path = os.path.join(dir_path, item)\n            \n            if os.path.isdir(item_path):\n                # Skip virtual environment directories\n                if config.get('ignore_venv') and item in VENV_DIRS:\n                    continue\n                scan_directory(item_path, graph, config)\n            elif os.path.isfile(item_path):\n                # Check if it's a Python file\n                if any(item_path.endswith(ext) for ext in PYTHON_EXTENSIONS):\n                    analyze_file(item_path, graph, config)\n    except PermissionError:\n        print(f\\\"Permission denied: {dir_path}\\\")\n    except Exception as e:\n        print(f\\\"Error scanning directory {dir_path}: {e}\\\")" RETURN n;
MERGE (n:Variable {id: "variable-items-scan_directory-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "items", n.file_path = ".\\scanner.py", n.location = "{\"line\": 20, \"column\": 8, \"end_line\": 20, \"end_column\": 13}", n.code_scope = "items" RETURN n;
MERGE (n:Variable {id: "variable-item_path-scan_directory-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "item_path", n.file_path = ".\\scanner.py", n.location = "{\"line\": 22, \"column\": 12, \"end_line\": 22, \"end_column\": 21}", n.code_scope = "item_path" RETURN n;
MERGE (n:Function {id: "function-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Function", n.name = "parse_requirements_file", n.file_path = ".\\scanner.py", n.location = "{\"line\": 38, \"column\": 0, \"end_line\": 105, \"end_column\": 23}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def parse_requirements_file(root_path):\n    \\\"\\\"\\\"Parse requirements.txt or setup.py to identify project dependencies\\\"\\\"\\\"\n    dependencies = {}\n    \n    # Try requirements.txt\n    req_files = ['requirements.txt', 'requirements-dev.txt', 'dev-requirements.txt']\n    for req_file in req_files:\n        req_path = os.path.join(root_path, req_file)\n        if os.path.exists(req_path):\n            try:\n                with open(req_path, 'r', encoding='utf-8') as f:\n                    for line in f:\n                        line = line.strip()\n                        if line and not line.startswith('#') and not line.startswith('-'):\n                            # Parse dependency (handle version specs)\n                            if '==' in line:\n                                name, version = line.split('==', 1)\n                                dependencies[name.strip()] = version.strip()\n                            elif '>=' in line:\n                                name = line.split('>=')[0].strip()\n                                dependencies[name] = 'latest'\n                            elif '>' in line:\n                                name = line.split('>')[0].strip()\n                                dependencies[name] = 'latest'\n                            else:\n                                # Simple package name\n                                dependencies[line] = 'latest'\n            except Exception as e:\n                print(f\\\"Error parsing {req_file}: {e}\\\")\n    \n    # Try setup.py (basic parsing)\n    setup_path = os.path.join(root_path, 'setup.py')\n    if os.path.exists(setup_path):\n        try:\n            with open(setup_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                # Look for install_requires or requires\n                import re\n                requires_match = re.search(r'install_requires\\\\s*=\\\\s*\\\\[(.*?)\\\\]', content, re.DOTALL)\n                if requires_match:\n                    requires_str = requires_match.group(1)\n                    # Extract package names from strings\n                    packages = re.findall(r'[\\\"\\\\']([^\\\"\\\\'>=<\\\\s]+)', requires_str)\n                    for pkg in packages:\n                        if pkg not in dependencies:\n                            dependencies[pkg] = 'latest'\n        except Exception as e:\n            print(f\\\"Error parsing setup.py: {e}\\\")\n    \n    # Try pyproject.toml (basic parsing)\n    pyproject_path = os.path.join(root_path, 'pyproject.toml')\n    if os.path.exists(pyproject_path):\n        try:\n            with open(pyproject_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n                # Look for dependencies in pyproject.toml\n                import re\n                deps_match = re.search(r'dependencies\\\\s*=\\\\s*\\\\[(.*?)\\\\]', content, re.DOTALL)\n                if deps_match:\n                    deps_str = deps_match.group(1)\n                    packages = re.findall(r'[\\\"\\\\']([^\\\"\\\\'>=<\\\\s]+)', deps_str)\n                    for pkg in packages:\n                        if pkg not in dependencies:\n                            dependencies[pkg] = 'latest'\n        except Exception as e:\n            print(f\\\"Error parsing pyproject.toml: {e}\\\")\n    \n    return dependencies" RETURN n;
MERGE (n:Variable {id: "variable-dependencies-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "dependencies", n.file_path = ".\\scanner.py", n.location = "{\"line\": 40, \"column\": 4, \"end_line\": 40, \"end_column\": 16}", n.code_scope = "dependencies" RETURN n;
MERGE (n:Variable {id: "variable-req_files-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "req_files", n.file_path = ".\\scanner.py", n.location = "{\"line\": 43, \"column\": 4, \"end_line\": 43, \"end_column\": 13}", n.code_scope = "req_files" RETURN n;
MERGE (n:Variable {id: "variable-req_path-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "req_path", n.file_path = ".\\scanner.py", n.location = "{\"line\": 45, \"column\": 8, \"end_line\": 45, \"end_column\": 16}", n.code_scope = "req_path" RETURN n;
MERGE (n:Variable {id: "variable-line-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "line", n.file_path = ".\\scanner.py", n.location = "{\"line\": 50, \"column\": 24, \"end_line\": 50, \"end_column\": 28}", n.code_scope = "line" RETURN n;
MERGE (n:Variable {id: "variable-name-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "name", n.file_path = ".\\scanner.py", n.location = "{\"line\": 57, \"column\": 32, \"end_line\": 57, \"end_column\": 36}", n.code_scope = "name" RETURN n;
MERGE (n:Variable {id: "variable-name-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "name", n.file_path = ".\\scanner.py", n.location = "{\"line\": 60, \"column\": 32, \"end_line\": 60, \"end_column\": 36}", n.code_scope = "name" RETURN n;
MERGE (n:Variable {id: "variable-setup_path-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "setup_path", n.file_path = ".\\scanner.py", n.location = "{\"line\": 69, \"column\": 4, \"end_line\": 69, \"end_column\": 14}", n.code_scope = "setup_path" RETURN n;
MERGE (n:Variable {id: "variable-content-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "content", n.file_path = ".\\scanner.py", n.location = "{\"line\": 73, \"column\": 16, \"end_line\": 73, \"end_column\": 23}", n.code_scope = "content" RETURN n;
MERGE (n:ExternalLibrary {id: "lib-re"}) ON CREATE SET n.type = "ExternalLibrary", n.name = "re", n.is_external = true, n.original_import = "re" RETURN n;
MERGE (n:Variable {id: "variable-requires_match-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "requires_match", n.file_path = ".\\scanner.py", n.location = "{\"line\": 76, \"column\": 16, \"end_line\": 76, \"end_column\": 30}", n.code_scope = "requires_match" RETURN n;
MERGE (n:Variable {id: "variable-requires_str-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "requires_str", n.file_path = ".\\scanner.py", n.location = "{\"line\": 78, \"column\": 20, \"end_line\": 78, \"end_column\": 32}", n.code_scope = "requires_str" RETURN n;
MERGE (n:Variable {id: "variable-packages-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "packages", n.file_path = ".\\scanner.py", n.location = "{\"line\": 80, \"column\": 20, \"end_line\": 80, \"end_column\": 28}", n.code_scope = "packages" RETURN n;
MERGE (n:Variable {id: "variable-pyproject_path-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "pyproject_path", n.file_path = ".\\scanner.py", n.location = "{\"line\": 88, \"column\": 4, \"end_line\": 88, \"end_column\": 18}", n.code_scope = "pyproject_path" RETURN n;
MERGE (n:Variable {id: "variable-content-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "content", n.file_path = ".\\scanner.py", n.location = "{\"line\": 92, \"column\": 16, \"end_line\": 92, \"end_column\": 23}", n.code_scope = "content" RETURN n;
MERGE (n:Variable {id: "variable-deps_match-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "deps_match", n.file_path = ".\\scanner.py", n.location = "{\"line\": 95, \"column\": 16, \"end_line\": 95, \"end_column\": 26}", n.code_scope = "deps_match" RETURN n;
MERGE (n:Variable {id: "variable-deps_str-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "deps_str", n.file_path = ".\\scanner.py", n.location = "{\"line\": 97, \"column\": 20, \"end_line\": 97, \"end_column\": 28}", n.code_scope = "deps_str" RETURN n;
MERGE (n:Variable {id: "variable-packages-parse_requirements_file-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "packages", n.file_path = ".\\scanner.py", n.location = "{\"line\": 98, \"column\": 20, \"end_line\": 98, \"end_column\": 28}", n.code_scope = "packages" RETURN n;
MERGE (n:Function {id: "function-scan_python_service-scanner-L0"}) ON CREATE SET n.type = "Function", n.name = "scan_python_service", n.file_path = ".\\scanner.py", n.location = "{\"line\": 107, \"column\": 0, \"end_line\": 149, \"end_column\": 16}", n.is_async = false, n.is_generator = false, n.decorators = [], n.code_scope = "def scan_python_service(root_path, custom_config=None):\n    \\\"\\\"\\\"Main function to scan a Python service/project\\\"\\\"\\\"\n    if custom_config is None:\n        custom_config = {}\n    \n    # Merge with default config\n    config = {**DEFAULT_CONFIG, **custom_config}\n    \n    print(f\\\"Starting scan of Python service at: {root_path}\\\")\n    print(f\\\"Configuration: {json.dumps(config, indent=2)}\\\")\n    \n    # Initialize graph structure\n    graph = {'nodes': [], 'relationships': []}\n    \n    # Clear previous data\n    clear_registries()\n    \n    # Try to find and parse dependency files\n    try:\n        dependencies = parse_requirements_file(root_path)\n        \n        # Pre-register all dependencies as external libraries\n        for lib_name, version in dependencies.items():\n            node = create_node(NODE_TYPES['EXTERNAL_LIBRARY'], lib_name, None, {\n                'is_external': True,\n                'version': version,\n                'from_requirements': True\n            })\n            graph['nodes'].append(node)\n            external_libraries[lib_name] = node\n        \n        if dependencies:\n            print(f\\\"Found {len(dependencies)} dependencies in requirements files\\\")\n    except Exception as e:\n        print(f\\\"Error parsing dependencies: {e}\\\")\n    \n    # Initialize root folder\n    get_or_create_folder_node(root_path, graph, config)\n    \n    # Start scanning\n    scan_directory(root_path, graph, config)\n    \n    return graph" RETURN n;
MERGE (n:Variable {id: "variable-custom_config-scan_python_service-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "custom_config", n.file_path = ".\\scanner.py", n.location = "{\"line\": 110, \"column\": 8, \"end_line\": 110, \"end_column\": 21}", n.code_scope = "custom_config" RETURN n;
MERGE (n:Variable {id: "variable-config-scan_python_service-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "config", n.file_path = ".\\scanner.py", n.location = "{\"line\": 113, \"column\": 4, \"end_line\": 113, \"end_column\": 10}", n.code_scope = "config" RETURN n;
MERGE (n:Variable {id: "variable-graph-scan_python_service-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "graph", n.file_path = ".\\scanner.py", n.location = "{\"line\": 119, \"column\": 4, \"end_line\": 119, \"end_column\": 9}", n.code_scope = "graph" RETURN n;
MERGE (n:Variable {id: "variable-dependencies-scan_python_service-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "dependencies", n.file_path = ".\\scanner.py", n.location = "{\"line\": 126, \"column\": 8, \"end_line\": 126, \"end_column\": 20}", n.code_scope = "dependencies" RETURN n;
MERGE (n:Variable {id: "variable-node-scan_python_service-scanner-L0"}) ON CREATE SET n.type = "Variable", n.name = "node", n.file_path = ".\\scanner.py", n.location = "{\"line\": 130, \"column\": 12, \"end_line\": 130, \"end_column\": 16}", n.code_scope = "node" RETURN n;
MATCH (a:Folder {id: "folder-_-Lg=="}), (b:File {id: "file-ast_analyzer.py-YXN0X2Fu"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "folder-_-Lg==-CONTAINS-file-ast_analyzer.py-YXN0X2Fu" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-ast"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-ast" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-import-os" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-import-os" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Function {id: "function-is_external_library-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-function-is_external_library-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-base_module-is_external_library-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-base_module-is_external_library-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Function {id: "function-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-function-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-base_lib_name-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-base_lib_name-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-node-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-node-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-class-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-__init__-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-__init__-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-__init__-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-__init__-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-get_location_info-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-get_location_info-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-get_location_info-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-get_location_info-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_Import-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_Import-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-import_name-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-import_name-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-import_name-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-import_name-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-as_name-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-as_name-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-as_name-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-as_name-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Function {id: "function-is_external_library-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-CALLS-function-is_external_library-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Variable {id: "variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}), (b:Function {id: "function-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0-CALLS-function-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-library_node-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Function {id: "function-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-CALLS-function-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-import_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-import_node-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-import_node-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-import_node-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Import-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Import-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Import-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-module-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-module-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-module-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-module-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-import_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-import_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-import_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-import_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-as_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-as_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-as_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-as_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-full_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-full_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-full_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-full_name-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Function {id: "function-is_external_library-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-CALLS-function-is_external_library-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Variable {id: "variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}), (b:Function {id: "function-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0-CALLS-function-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-library_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Function {id: "function-get_or_create_external_library_node-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-CALLS-function-get_or_create_external_library_node-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-import_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-import_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-import_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-import_node-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ImportFrom-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_ImportFrom-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-class_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-class_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-class_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-class_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-class_node-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-class_node-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-class_node-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-class_node-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-previous_class-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-previous_class-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-previous_class-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-previous_class-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-base_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-base_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-base_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-base_name-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_ClassDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_ClassDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-func_name-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-func_name-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-func_name-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-func_name-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-method_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-method_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-method_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-method_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-previous_method-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-previous_method-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-previous_method-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-previous_method-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-func_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-func_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-func_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_FunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-func_node-PythonASTVisitor_visit_FunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-func_name-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-func_name-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-func_name-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-func_name-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-method_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-method_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-method_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-method_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-previous_method-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-previous_method-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-previous_method-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-previous_method-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-func_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-func_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-func_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_AsyncFunctionDef-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-func_node-PythonASTVisitor_visit_AsyncFunctionDef-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_Assign-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_Assign-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-var_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-var_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-var_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-var_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-var_node-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-var_node-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-var_node-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-var_node-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-callee_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-callee_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-callee_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-callee_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-init_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-init_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-init_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-init_name-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Assign-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Assign-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-method-visit_Call-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:Class {id: "class-PythonASTVisitor-ast_analyzer-L0"}), (b:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "class-PythonASTVisitor-ast_analyzer-L0-CONTAINS-method-visit_Call-PythonASTVisitor-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-callee_name-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-callee_name-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-callee_name-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Call-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-callee_name-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Call-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Call-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Call-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Call-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-source_id-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-relationship-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:Method {id: "method-visit_Call-PythonASTVisitor-ast_analyzer-L0"}), (b:Variable {id: "variable-relationship-PythonASTVisitor_visit_Call-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:DECLARES]->(b) ON CREATE SET r.id = "method-visit_Call-PythonASTVisitor-ast_analyzer-L0-DECLARES-variable-relationship-PythonASTVisitor_visit_Call-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Function {id: "function-analyze_file-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-function-analyze_file-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-source_code-analyze_file-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-source_code-analyze_file-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-tree-analyze_file-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-tree-analyze_file-ast_analyzer-L0" RETURN r;
MATCH (a:File {id: "file-ast_analyzer.py-YXN0X2Fu"}), (b:Variable {id: "variable-visitor-analyze_file-ast_analyzer-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-ast_analyzer.py-YXN0X2Fu-CONTAINS-variable-visitor-analyze_file-ast_analyzer-L0" RETURN r;
MATCH (a:Folder {id: "folder-_-Lg=="}), (b:File {id: "file-constants.py-Y29uc3Rh"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "folder-_-Lg==-CONTAINS-file-constants.py-Y29uc3Rh" RETURN r;
MATCH (a:File {id: "file-constants.py-Y29uc3Rh"}), (b:Variable {id: "variable-NODE_TYPES--constants-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-constants.py-Y29uc3Rh-CONTAINS-variable-NODE_TYPES--constants-L0" RETURN r;
MATCH (a:File {id: "file-constants.py-Y29uc3Rh"}), (b:Variable {id: "variable-REL_TYPES--constants-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-constants.py-Y29uc3Rh-CONTAINS-variable-REL_TYPES--constants-L0" RETURN r;
MATCH (a:File {id: "file-constants.py-Y29uc3Rh"}), (b:Variable {id: "variable-DEFAULT_CONFIG--constants-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-constants.py-Y29uc3Rh-CONTAINS-variable-DEFAULT_CONFIG--constants-L0" RETURN r;
MATCH (a:File {id: "file-constants.py-Y29uc3Rh"}), (b:Variable {id: "variable-VENV_DIRS--constants-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-constants.py-Y29uc3Rh-CONTAINS-variable-VENV_DIRS--constants-L0" RETURN r;
MATCH (a:File {id: "file-constants.py-Y29uc3Rh"}), (b:Variable {id: "variable-PYTHON_EXTENSIONS--constants-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-constants.py-Y29uc3Rh-CONTAINS-variable-PYTHON_EXTENSIONS--constants-L0" RETURN r;
MATCH (a:File {id: "file-constants.py-Y29uc3Rh"}), (b:Variable {id: "variable-STANDARD_LIBRARY_MODULES--constants-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-constants.py-Y29uc3Rh-CONTAINS-variable-STANDARD_LIBRARY_MODULES--constants-L0" RETURN r;
MATCH (a:Folder {id: "folder-_-Lg=="}), (b:File {id: "file-exporters.py-ZXhwb3J0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "folder-_-Lg==-CONTAINS-file-exporters.py-ZXhwb3J0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Import {id: "import-json"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-import-json" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Import {id: "import-json"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-import-json" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-import-os" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-import-os" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Import {id: "import-datetime_datetime"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-import-datetime_datetime" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Import {id: "import-datetime_datetime"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-import-datetime_datetime" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Function {id: "function-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-function-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-valid_relationships-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-valid_relationships-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-node_ids-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-node_ids-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-enhanced_nodes-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-enhanced_nodes-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-enhanced_node-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-enhanced_node-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-content_lists-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-content_lists-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-cleaned_graph-export_to_json-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-cleaned_graph-export_to_json-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Function {id: "function-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-function-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-registry-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-registry-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-registry-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-registry-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-registry-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-registry-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Function {id: "function-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-function-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-valid_relationships-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-valid_relationships-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-node_ids-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-node_ids-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-source_exists-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-source_exists-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-target_exists-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-target_exists-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-constraints-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-constraints-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-constraints_query-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-constraints_query-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-nodes_queries-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-nodes_queries-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-props-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-props-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-content_lists-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-content_lists-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:Variable {id: "variable-content_lists-export_to_neo4j-exporters-L0"}), (b:Function {id: "function-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-content_lists-export_to_neo4j-exporters-L0-CALLS-function-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Function {id: "function-get_content_lists_by_name-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CALLS-function-get_content_lists_by_name-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-prop_entries-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-prop_entries-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-escaped-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-escaped-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-prop_string-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-prop_string-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-query-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-query-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-nodes_query-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-nodes_query-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-rels_queries-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-rels_queries-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-source_node-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-source_node-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-target_node-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-target_node-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-query-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-query-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-rels_query-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-rels_query-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-stats-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-stats-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:File {id: "file-exporters.py-ZXhwb3J0"}), (b:Variable {id: "variable-transaction-export_to_neo4j-exporters-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-exporters.py-ZXhwb3J0-CONTAINS-variable-transaction-export_to_neo4j-exporters-L0" RETURN r;
MATCH (a:Folder {id: "folder-_-Lg=="}), (b:File {id: "file-helpers.py-aGVscGVy"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "folder-_-Lg==-CONTAINS-file-helpers.py-aGVscGVy" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-import-os" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-IMPORTS-import-os" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-base64"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-import-base64" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-base64"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-IMPORTS-import-base64" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-hashlib"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-import-hashlib" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-hashlib"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-IMPORTS-import-hashlib" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-pathlib_Path"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-import-pathlib_Path" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Import {id: "import-pathlib_Path"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-IMPORTS-import-pathlib_Path" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_registry--helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_registry--helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-content_registry--helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-content_registry--helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-external_libraries--helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-external_libraries--helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-global_context--helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-global_context--helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-is_placeholder-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-is_placeholder-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_name-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_name-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-folder_name-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-folder_name-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-normalized_path-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-normalized_path-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-path_segments-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-path_segments-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-dir_name-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-dir_name-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-path_hash-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-path_hash-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_folder-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_folder-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-path_hash-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-path_hash-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-normalized_path-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-normalized_path-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-path_hash-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-path_hash-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-class_context-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-class_context-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_class-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_class-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_filename-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_filename-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-scope_context-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-scope_context-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-clean_scope-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-clean_scope-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-metadata-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-metadata-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-location-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-location-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node_id-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node_id-create_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-node_id-create_node-helpers-L0"}), (b:Function {id: "function-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-node_id-create_node-helpers-L0-CALLS-function-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-generate_meaningful_id-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-generate_meaningful_id-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-metadata-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-metadata-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-relationship-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-relationship-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-registry-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-registry-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-registry-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-registry-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-registry-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-registry-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-registry-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-registry-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-registry-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-registry-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-lines-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-lines-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-start_line-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-start_line-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-end_line-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-end_line-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-col_offset-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-col_offset-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-end_col_offset-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-end_col_offset-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-code_lines-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-code_lines-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-col_offset-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-col_offset-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-end_col_offset-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-end_col_offset-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-folder_name-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-folder_name-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-node-get_or_create_folder_node-helpers-L0"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-node-get_or_create_folder_node-helpers-L0-CALLS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-parent_path-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-parent_path-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-parent_node-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-parent_node-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-parent_node-get_or_create_folder_node-helpers-L0"}), (b:Function {id: "function-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-parent_node-get_or_create_folder_node-helpers-L0-CALLS-function-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-relationship-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-relationship-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-relationship-get_or_create_folder_node-helpers-L0"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-relationship-get_or_create_folder_node-helpers-L0-CALLS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-items-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-items-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-folder_content-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-folder_content-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-item_path-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-item_path-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-folders-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-folders-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-files-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-files-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-filename-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-filename-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-node-get_or_create_file_node-helpers-L0"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-node-get_or_create_file_node-helpers-L0-CALLS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-folder_path-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-folder_path-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-folder_node-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-folder_node-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-folder_node-get_or_create_file_node-helpers-L0"}), (b:Function {id: "function-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-folder_node-get_or_create_file_node-helpers-L0-CALLS-function-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-get_or_create_folder_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-get_or_create_folder_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-relationship-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-relationship-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-relationship-get_or_create_file_node-helpers-L0"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-relationship-get_or_create_file_node-helpers-L0-CALLS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-file_content-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-file_content-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_entity_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-create_entity_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-key-create_entity_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-key-create_entity_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-code_content-create_entity_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-code_content-create_entity_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-code_content-create_entity_node-helpers-L0"}), (b:Function {id: "function-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-code_content-create_entity_node-helpers-L0-CALLS-function-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-extract_source_code-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-extract_source_code-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-register_content-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-register_content-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-node-create_entity_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-node-create_entity_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-node-create_entity_node-helpers-L0"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-node-create_entity_node-helpers-L0-CALLS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-create_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-file_node-create_entity_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-file_node-create_entity_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-file_node-create_entity_node-helpers-L0"}), (b:Function {id: "function-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-file_node-create_entity_node-helpers-L0-CALLS-function-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-get_or_create_file_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-get_or_create_file_node-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Variable {id: "variable-relationship-create_entity_node-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-variable-relationship-create_entity_node-helpers-L0" RETURN r;
MATCH (a:Variable {id: "variable-relationship-create_entity_node-helpers-L0"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-relationship-create_entity_node-helpers-L0-CALLS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-create_relationship-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CALLS-function-create_relationship-helpers-L0" RETURN r;
MATCH (a:File {id: "file-helpers.py-aGVscGVy"}), (b:Function {id: "function-clear_registries-helpers-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-helpers.py-aGVscGVy-CONTAINS-function-clear_registries-helpers-L0" RETURN r;
MATCH (a:Folder {id: "folder-_-Lg=="}), (b:File {id: "file-main.py-bWFpbi5w"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "folder-_-Lg==-CONTAINS-file-main.py-bWFpbi5w" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-sys"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-import-sys" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-sys"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-import-sys" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-import-os" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-import-os" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-argparse"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-import-argparse" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-argparse"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-import-argparse" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-time"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-import-time" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Import {id: "import-time"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-import-time" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:ExternalLibrary {id: "lib-scanner"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-lib-scanner" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:ExternalLibrary {id: "lib-exporters"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-lib-exporters" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:ExternalLibrary {id: "lib-exporters"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-lib-exporters" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Function {id: "function-parse_arguments-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-function-parse_arguments-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-parser-parse_arguments-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-parser-parse_arguments-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Function {id: "function-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-function-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-args-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-args-main-main-L0" RETURN r;
MATCH (a:Variable {id: "variable-args-main-main-L0"}), (b:Function {id: "function-parse_arguments-main-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-args-main-main-L0-CALLS-function-parse_arguments-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Function {id: "function-parse_arguments-main-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CALLS-function-parse_arguments-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-config-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-config-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-start_time-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-start_time-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-graph-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-graph-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-end_time-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-end_time-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-node_type_count-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-node_type_count-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-node_type-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-node_type-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-external_libraries-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-external_libraries-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-lib_import_counts-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-lib_import_counts-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-target_node-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-target_node-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-lib_name-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-lib_name-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-sorted_libs-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-sorted_libs-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-node_ids-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-node_ids-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-bad_relationships-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-bad_relationships-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-source_exists-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-source_exists-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-target_exists-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-target_exists-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Variable {id: "variable-cypher-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CONTAINS-variable-cypher-main-main-L0" RETURN r;
MATCH (a:File {id: "file-main.py-bWFpbi5w"}), (b:Function {id: "function-main-main-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-main.py-bWFpbi5w-CALLS-function-main-main-L0" RETURN r;
MATCH (a:Folder {id: "folder-_-Lg=="}), (b:File {id: "file-scanner.py-c2Nhbm5l"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "folder-_-Lg==-CONTAINS-file-scanner.py-c2Nhbm5l" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-import-os" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Import {id: "import-os"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-import-os" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Import {id: "import-json"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-import-json" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Import {id: "import-json"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-import-json" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Import {id: "import-pathlib_Path"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-import-pathlib_Path" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Import {id: "import-pathlib_Path"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-import-pathlib_Path" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-constants"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-constants" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-helpers"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-helpers" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-ast_analyzer"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-ast_analyzer" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Function {id: "function-scan_directory-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-function-scan_directory-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-items-scan_directory-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-items-scan_directory-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-item_path-scan_directory-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-item_path-scan_directory-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Function {id: "function-scan_directory-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CALLS-function-scan_directory-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Function {id: "function-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-function-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-dependencies-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-dependencies-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-req_files-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-req_files-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-req_path-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-req_path-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-line-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-line-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-name-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-name-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-name-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-name-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-setup_path-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-setup_path-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-content-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-content-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-re"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-re" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-requires_match-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-requires_match-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-requires_str-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-requires_str-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-packages-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-packages-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-pyproject_path-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-pyproject_path-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-content-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-content-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:ExternalLibrary {id: "lib-re"}) WHERE a <> b MERGE (a)-[r:IMPORTS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-IMPORTS-lib-re" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-deps_match-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-deps_match-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-deps_str-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-deps_str-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-packages-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-packages-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Function {id: "function-scan_python_service-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-function-scan_python_service-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-custom_config-scan_python_service-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-custom_config-scan_python_service-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-config-scan_python_service-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-config-scan_python_service-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-graph-scan_python_service-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-graph-scan_python_service-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-dependencies-scan_python_service-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-dependencies-scan_python_service-scanner-L0" RETURN r;
MATCH (a:Variable {id: "variable-dependencies-scan_python_service-scanner-L0"}), (b:Function {id: "function-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "variable-dependencies-scan_python_service-scanner-L0-CALLS-function-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Function {id: "function-parse_requirements_file-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CALLS-function-parse_requirements_file-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Variable {id: "variable-node-scan_python_service-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CONTAINS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CONTAINS-variable-node-scan_python_service-scanner-L0" RETURN r;
MATCH (a:File {id: "file-scanner.py-c2Nhbm5l"}), (b:Function {id: "function-scan_directory-scanner-L0"}) WHERE a <> b MERGE (a)-[r:CALLS]->(b) ON CREATE SET r.id = "file-scanner.py-c2Nhbm5l-CALLS-function-scan_directory-scanner-L0" RETURN r;