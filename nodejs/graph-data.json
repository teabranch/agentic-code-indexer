{
  "nodes": [
    {
      "id": "folder-_-Li8=",
      "type": "Folder",
      "name": ".",
      "filePath": "./",
      "contentCount": 15,
      "contentSummary": "2 folders, 13 files"
    },
    {
      "id": "folder-_-Lg==",
      "type": "Folder",
      "name": ".",
      "filePath": ".",
      "contentCount": 15,
      "contentSummary": "2 folders, 13 files"
    },
    {
      "id": "file-ast.js-YXN0Lmpz",
      "type": "File",
      "name": "ast.js",
      "filePath": "ast.js",
      "fileSize": 7261,
      "lineCount": 153
    },
    {
      "id": "function-analyzeFile-ast-L15",
      "type": "Function",
      "name": "analyzeFile",
      "filePath": "ast.js",
      "location": {
        "start": {
          "line": 15,
          "column": 0
        },
        "end": {
          "line": 150,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function analyzeFile(filePath, graph, config) {\r\n    console.log(`Analyzing file: ${filePath}`);\r\n    const fileNode = getOrCreateFileNode(filePath, graph, config);\r\n    globalContext.currentClassContext = null;\r\n    globalContext.currentMethodContext = null;\r\n    globalContext.currentScopeContext = null;\r\n    globalContext.currentClassNode = null;\r\n    globalContext.currentMethodNode = null;\r\n\r\n    let code;\r\n    try {\r\n        code = fs.readFileSync(filePath, 'utf-8');\r\n    } catch (error) {\r\n        console.error(`Error reading file ${filePath}:`, error.message);\r\n        return;\r\n    }\r\n\r\n    let ast;\r\n    try {\r\n        ast = parser.parse(code, {\r\n            sourceType: 'module',\r\n            plugins: ['jsx', 'typescript', 'classProperties', 'decorators-legacy']\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error parsing ${filePath}:`, error.message);\r\n        return;\r\n    }\r\n\r\n    // Scope tracker to manage context during AST traversal\r\n    const scopeTracker = {\r\n        currentClass: null,\r\n        currentMethod: null,\r\n        declaredVariables: new Map(),\r\n        importedModules: new Map()\r\n    };\r\n\r\n    traverse(ast, {\r\n        ImportDeclaration(path) {\r\n            const importSource = path.node.source.value;\r\n            // External or internal import handling is retained here.\r\n            if (config.trackExternalLibraries && !importSource.startsWith('.') && !importSource.startsWith('/')) {\r\n                // External library logic (not expanded for brevity)\r\n                // Handle external library import\r\n                const libraryNode = getOrCreateExternalLibraryNode(importSource);\r\n                createRelationship(fileNode.id, libraryNode.id, REL_TYPES.IMPORTS);\r\n\r\n                // Track imported specifiers\r\n                path.node.specifiers.forEach(specifier => {\r\n                    const importedName = specifier.local.name;\r\n                    scopeTracker.importedModules.set(importedName, libraryNode.id);\r\n                });\r\n            } else {\r\n                const importNode = createEntityNode(NODE_TYPES.IMPORT, importSource, filePath, path.node.loc, {}, code, graph, config);\r\n                graph.relationships.push(createRelationship(fileNode.id, importNode.id, REL_TYPES.IMPORTS));\r\n                path.node.specifiers.forEach(specifier => {\r\n                    scopeTracker.importedModules.set(specifier.local.name, importNode.id);\r\n                });\r\n            }\r\n        },\r\n        ClassDeclaration(path) {\r\n            const className = path.node.id.name;\r\n            const classNode = createEntityNode(NODE_TYPES.CLASS, className, filePath, path.node.loc, {}, code, graph, config);\r\n            globalContext.currentClassContext = className;\r\n            scopeTracker.currentClass = classNode.id;\r\n            if (path.node.superClass) {\r\n                const superClassName = path.node.superClass.name;\r\n                if (scopeTracker.importedModules.has(superClassName)) {\r\n                    graph.relationships.push(createRelationship(classNode.id, scopeTracker.importedModules.get(superClassName), REL_TYPES.EXTENDS));\r\n                }\r\n            }\r\n        },\r\n        ClassMethod(path) {\r\n            if (!scopeTracker.currentClass) return;\r\n            const methodName = path.node.key.name;\r\n            const methodNode = createEntityNode(\r\n                NODE_TYPES.METHOD,\r\n                methodName,\r\n                filePath,\r\n                path.node.loc,\r\n                { isAsync: path.node.async, isGenerator: path.node.generator, parentClass: globalContext.currentClassContext },\r\n                code,\r\n                graph,\r\n                config\r\n            );\r\n            globalContext.currentMethodContext = methodName;\r\n            globalContext.currentScopeContext = `${globalContext.currentClassContext}.${methodName}`;\r\n            graph.relationships.push(createRelationship(scopeTracker.currentClass, methodNode.id, REL_TYPES.CONTAINS));\r\n            scopeTracker.currentMethod = methodNode.id;\r\n        },\r\n        FunctionDeclaration(path) {\r\n            const funcName = path.node.id.name;\r\n            const funcNode = createEntityNode(NODE_TYPES.FUNCTION, funcName, filePath, path.node.loc, { isAsync: path.node.async, isGenerator: path.node.generator }, code, graph, config);\r\n            globalContext.currentMethodContext = null;\r\n            globalContext.currentScopeContext = funcName;\r\n            scopeTracker.declaredVariables.set(funcName, funcNode.id);\r\n        },\r\n        VariableDeclarator(path) {\r\n            const varName = path.node.id.name;\r\n            const varNode = createEntityNode(NODE_TYPES.VARIABLE, varName, filePath, path.node.loc, {}, code, graph, config);\r\n            scopeTracker.declaredVariables.set(varName, varNode.id);\r\n            if (path.node.init) {\r\n                if (path.node.init.type === 'CallExpression' && path.node.init.callee.name && scopeTracker.declaredVariables.has(path.node.init.callee.name)) {\r\n                    graph.relationships.push(createRelationship(varNode.id, scopeTracker.declaredVariables.get(path.node.init.callee.name), REL_TYPES.CALLS));\r\n                } else if (path.node.init.type === 'Identifier' && scopeTracker.declaredVariables.has(path.node.init.name)) {\r\n                    graph.relationships.push(createRelationship(varNode.id, scopeTracker.declaredVariables.get(path.node.init.name), REL_TYPES.REFERENCES));\r\n                }\r\n            }\r\n            if (scopeTracker.currentMethod) {\r\n                graph.relationships.push(createRelationship(scopeTracker.currentMethod, varNode.id, REL_TYPES.DECLARES));\r\n            } else if (scopeTracker.currentClass) {\r\n                graph.relationships.push(createRelationship(scopeTracker.currentClass, varNode.id, REL_TYPES.DECLARES));\r\n            }\r\n        },\r\n        BlockStatement: {\r\n            enter(path) {\r\n                path.node._parentScope = globalContext.currentScopeContext;\r\n            },\r\n            exit(path) {\r\n                globalContext.currentScopeContext = path.node._parentScope;\r\n            }\r\n        },\r\n        CallExpression(path) {\r\n            if (path.node.callee.type === 'Identifier') {\r\n                const calleeName = path.node.callee.name;\r\n                if (calleeName === 'require' && path.node.arguments?.[0]?.type === 'StringLiteral') {\r\n                    // ...existing require handling...\r\n                }\r\n                if (scopeTracker.declaredVariables.has(calleeName)) {\r\n                    const sourceId = scopeTracker.currentMethod || scopeTracker.currentClass || fileNode.id;\r\n                    graph.relationships.push(createRelationship(sourceId, scopeTracker.declaredVariables.get(calleeName), REL_TYPES.CALLS));\r\n                }\r\n            }\r\n        }\r\n        // ...other AST visitors as needed...\r\n    });\r\n}"
    },
    {
      "id": "file-constants.js-Y29uc3Rh",
      "type": "File",
      "name": "constants.js",
      "filePath": "constants.js",
      "fileSize": 1194,
      "lineCount": 61
    },
    {
      "id": "file-exporters.js-ZXhwb3J0",
      "type": "File",
      "name": "exporters.js",
      "filePath": "exporters.js",
      "fileSize": 5508,
      "lineCount": 119
    },
    {
      "id": "function-exportToNeo4j-exporters-L4",
      "type": "Function",
      "name": "exportToNeo4j",
      "filePath": "exporters.js",
      "location": {
        "start": {
          "line": 4,
          "column": 0
        },
        "end": {
          "line": 79,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function exportToNeo4j(graph, config) {\r\n\r\n  console.log('[exportToNeo4j] Starting export'); // Added log\r\n  console.log('[exportToNeo4j] Entities:', JSON.stringify(graph.nodes)); // Log entities\r\n  const validRelationships = graph.relationships.filter(rel => {\r\n    console.log(rel);\r\n    if (!rel.source || !rel.target) return false;\r\n    if (typeof rel.source === 'string' && rel.source.startsWith('placeholder_')) return false;\r\n    if (typeof rel.target === 'string' && rel.target.startsWith('placeholder_')) return false;\r\n    const sourceExists = graph.nodes.some(node => node.id === rel.source);\r\n    const targetExists = graph.nodes.some(node => node.id === rel.target);\r\n    return sourceExists && targetExists;\r\n  });\r\n  console.log(`[exportToNeo4j] Valid relationships count: ${validRelationships.length}`); // Added log\r\n  \r\n  const constraints = [\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Folder) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:File) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Class) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Method) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Function) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Variable) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Import) REQUIRE n.id IS UNIQUE',\r\n    'CREATE CONSTRAINT IF NOT EXISTS FOR (n:ExternalLibrary) REQUIRE n.id IS UNIQUE',\r\n    'CREATE INDEX IF NOT EXISTS FOR (n:Folder) ON (n.name)',\r\n    'CREATE INDEX IF NOT EXISTS FOR (n:File) ON (n.name)'\r\n  ].join(';\\n');\r\n\r\nconst nodesQuery = graph.nodes.map(node => {\r\n    const props = { ...node };\r\n    delete props.id; // Remove 'id' since it's used in MERGE\r\n\r\n    if (config.captureContent && [NODE_TYPES.FOLDER, NODE_TYPES.FILE, NODE_TYPES.CLASS, NODE_TYPES.METHOD].includes(node.type)) {\r\n      // Assume content lists are already attached\r\n    }\r\n\r\n    // Escape entry code if needed\r\n    const propEntries = Object.entries(props)\r\n      .filter(([, v]) => v !== null && v !== undefined)\r\n      .map(([k, v]) => {\r\n        if (k === 'codeScope' && typeof v === 'string') {\r\n          // Escape the codeScope property explicitly\r\n          const escaped = v.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\r\n          return `n.${k} = ${JSON.stringify(escaped)}`;\r\n        }\r\n        // Handle nested objects (store as JSON string)\r\n        if (typeof v === 'object' && !Array.isArray(v)) {\r\n          return `n.${k} = ${JSON.stringify(JSON.stringify(v))}`;\r\n        }\r\n        return `n.${k} = ${JSON.stringify(v)}`;\r\n      })\r\n      .join(', ');\r\n\r\n    return `MERGE (n:${node.type} {id: ${JSON.stringify(node.id)}}) ON CREATE SET ${propEntries} RETURN n`;\r\n}).join(';\\n');\r\n\r\n  \r\n  const relsQuery = validRelationships.map(rel => {\r\n    const sourceNode = graph.nodes.find(node => node.id === rel.source);\r\n    const targetNode = graph.nodes.find(node => node.id === rel.target);\r\n    if (!sourceNode || !targetNode || sourceNode.id === targetNode.id) return '';\r\n    return `MATCH (a:${sourceNode.type} {id: ${JSON.stringify(sourceNode.id)}}), (b:${targetNode.type} {id: ${JSON.stringify(targetNode.id)}}) WHERE a <> b MERGE (a)-[r:${rel.type}]->(b) ON CREATE SET r.id = ${JSON.stringify(rel.id)} RETURN r`;\r\n  }).filter(Boolean).join(';\\n');\r\n  \r\n  const stats = `// Export summary:\r\n  // - ${graph.nodes.length} nodes\r\n  // - ${validRelationships.length} relationships\r\n  // - ${new Set(graph.nodes.map(n => n.type)).size} node types\r\n  // - ${new Set(validRelationships.map(r => r.type)).size} relationship types\r\n  // Exported on: ${new Date().toISOString()}`;\r\n  \r\n  //const transaction = `BEGIN;\\n${constraints};\\n${nodesQuery};\\n${relsQuery};\\nCOMMIT;`;\r\n  const transaction = `${constraints};\\n${nodesQuery};\\n${relsQuery};`;\r\n  console.log('[exportToNeo4j] Export query constructed'); // Added log\r\n  return `${stats}\\n\\n${transaction}`;\r\n}"
    },
    {
      "id": "function-exportToJSON-exporters-L81",
      "type": "Function",
      "name": "exportToJSON",
      "filePath": "exporters.js",
      "location": {
        "start": {
          "line": 81,
          "column": 0
        },
        "end": {
          "line": 116,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function exportToJSON(graph, filePath, config) {\r\n  console.log(`[exportToJSON] Exporting relationships: ${graph.relationships?.length}`); // Existing log\r\n  const validRelationships = graph.relationships.filter(rel => {\r\n    if (!rel.source || !rel.target) return false;\r\n    if (typeof rel.source === 'string' && rel.source.startsWith('placeholder_')) return false;\r\n    if (typeof rel.target === 'string' && rel.target.startsWith('placeholder_')) return false;\r\n    const sourceExists = graph.nodes.some(node => node.id === rel.source);\r\n    const targetExists = graph.nodes.some(node => node.id === rel.target);\r\n    return sourceExists && targetExists;\r\n  });\r\n  \r\n  const enhancedNodes = graph.nodes.map(node => {\r\n    const enhancedNode = { ...node };\r\n    // Attach content lists if needed\r\n    return enhancedNode;\r\n  });\r\n  \r\n  const cleanedGraph = {\r\n    nodes: enhancedNodes,\r\n    relationships: validRelationships,\r\n    contentRegistrySummary: {\r\n      folders: 0, // Can be populated if needed\r\n      files: 0,\r\n      classes: 0,\r\n      methods: 0\r\n    }\r\n  };\r\n  \r\n  try { // Added try/catch for error visibility\r\n    fs.writeFileSync(filePath, JSON.stringify(cleanedGraph, null, 2));\r\n    console.log(`[exportToJSON] Graph exported to ${filePath}`);\r\n  } catch (error) {\r\n    console.error(`[exportToJSON] Error exporting graph: ${error.message}`);\r\n    throw error;\r\n  }\r\n}"
    },
    {
      "id": "file-helpers.js-aGVscGVy",
      "type": "File",
      "name": "helpers.js",
      "filePath": "helpers.js",
      "fileSize": 9161,
      "lineCount": 230
    },
    {
      "id": "function-isPlaceholder-helpers-L25",
      "type": "Function",
      "name": "isPlaceholder",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 25,
          "column": 0
        },
        "end": {
          "line": 27,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function isPlaceholder(id) {\r\n  return typeof id === 'string' && id.startsWith('placeholder_');\r\n}"
    },
    {
      "id": "function-generateMeaningfulId-helpers-L29",
      "type": "Function",
      "name": "generateMeaningfulId",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 29,
          "column": 0
        },
        "end": {
          "line": 66,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function generateMeaningfulId(type, name, filePath = null, location = null) {\r\n  const cleanName = name.replace(/[^a-zA-Z0-9_]/g, '_').substring(0, 40);\r\n  let id = `${type.toLowerCase()}-${cleanName}`;\r\n\r\n  if (type === NODE_TYPES.FOLDER && filePath) {\r\n    const folderName = path.basename(filePath);\r\n    const normalizedPath = path.normalize(filePath).replace(/\\\\/g, '/');\r\n    id = `folder-${folderName.replace(/[^a-zA-Z0-9_]/g, '_')}-${Buffer.from(normalizedPath).toString('base64').substring(0, 8)}`;\r\n  } else if (type === NODE_TYPES.FILE && filePath) {\r\n    const filename = path.basename(filePath);\r\n    const normalizedPath = path.normalize(filePath).replace(/\\\\/g, '/');\r\n    id = `file-${filename.replace(/[^a-zA-Z0-9_.]/g, '_')}-${Buffer.from(normalizedPath).toString('base64').substring(0, 8)}`;\r\n  } else if (type === NODE_TYPES.CLASS && filePath) {\r\n    const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n    id = `class-${cleanName}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n    if (location) { id += `-L${location.start.line}`; }\r\n  } else if (type === NODE_TYPES.METHOD && filePath) {\r\n    const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n    const classContext = globalContext.currentClassContext || '';\r\n    id = `method-${cleanName}-${classContext}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n    if (location) { id += `-L${location.start.line}`; }\r\n  } else if (type === NODE_TYPES.FUNCTION && filePath) {\r\n    const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n    id = `function-${cleanName}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n    if (location) { id += `-L${location.start.line}`; }\r\n  } else if (type === NODE_TYPES.VARIABLE && filePath) {\r\n    const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n    const scopeContext = globalContext.currentScopeContext || '';\r\n    id = `variable-${cleanName}-${scopeContext}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n    if (location) { id += `-L${location.start.line}`; }\r\n  } else if (type === NODE_TYPES.EXTERNAL_LIBRARY) {\r\n    const version = globalContext.packageVersions && globalContext.packageVersions[name]\r\n      ? `-${globalContext.packageVersions[name].replace(/[^a-zA-Z0-9_.]/g, '_')}` : '';\r\n    id = `lib-${cleanName}${version}`;\r\n  }\r\n\r\n  return id;\r\n}"
    },
    {
      "id": "function-createNode-helpers-L68",
      "type": "Function",
      "name": "createNode",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 68,
          "column": 0
        },
        "end": {
          "line": 76,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function createNode(type, name, filePath = null, metadata = {}) {\r\n  const location = metadata.location || null;\r\n  const id = generateMeaningfulId(type, name, filePath, location);\r\n  const node = { id, type, name, filePath, ...metadata };\r\n //externalLibraries.set(baseLibName, node);\r\n\r\n  // Assuming graph is managed externally (set in scanner.js)\r\n  return node;\r\n}"
    },
    {
      "id": "function-createRelationship-helpers-L78",
      "type": "Function",
      "name": "createRelationship",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 78,
          "column": 0
        },
        "end": {
          "line": 86,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function createRelationship(sourceId, targetId, type, metadata = {}) {\r\n  return {\r\n    id: `${sourceId}-${type}-${targetId}`,\r\n    source: sourceId,\r\n    target: targetId,\r\n    type,\r\n    ...metadata\r\n  };\r\n}"
    },
    {
      "id": "function-registerContent-helpers-L88",
      "type": "Function",
      "name": "registerContent",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 88,
          "column": 0
        },
        "end": {
          "line": 103,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function registerContent(type, name, content, config) {\r\n  if (!config.captureContent) return;\r\n  let registry;\r\n  switch (type) {\r\n    case NODE_TYPES.FOLDER: registry = contentRegistry.folderContents; break;\r\n    case NODE_TYPES.FILE: registry = contentRegistry.fileContents; break;\r\n    case NODE_TYPES.CLASS: registry = contentRegistry.classScopes; break;\r\n    case NODE_TYPES.METHOD: registry = contentRegistry.methodScopes; break;\r\n    default: return;\r\n  }\r\n  if (registry.has(name)) {\r\n    registry.get(name).push(content);\r\n  } else {\r\n    registry.set(name, [content]);\r\n  }\r\n}"
    },
    {
      "id": "function-extractSourceCode-helpers-L105",
      "type": "Function",
      "name": "extractSourceCode",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 105,
          "column": 0
        },
        "end": {
          "line": 123,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function extractSourceCode(sourceCode, loc) {\r\n  if (!sourceCode || !loc) return '';\r\n  try {\r\n    const lines = sourceCode.split('\\n');\r\n    const startLine = loc.start.line - 1;\r\n    const endLine = loc.end.line - 1;\r\n    if (startLine === endLine) {\r\n      return lines[startLine].substring(loc.start.column, loc.end.column);\r\n    }\r\n    const codeLines = [];\r\n    codeLines.push(lines[startLine].substring(loc.start.column));\r\n    for (let i = startLine + 1; i < endLine; i++) { codeLines.push(lines[i]); }\r\n    codeLines.push(lines[endLine].substring(0, loc.end.column));\r\n    return codeLines.join('\\n');\r\n  } catch (error) {\r\n    console.error('Error extracting source code:', error.message);\r\n    return '';\r\n  }\r\n}"
    },
    {
      "id": "function-getOrCreateFolderNode-helpers-L125",
      "type": "Function",
      "name": "getOrCreateFolderNode",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 125,
          "column": 0
        },
        "end": {
          "line": 157,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function getOrCreateFolderNode(folderPath, graph, config) {\r\n  if (nodeRegistry.folderNodes.has(folderPath)) return nodeRegistry.folderNodes.get(folderPath);\r\n  const folderName = path.basename(folderPath);\r\n  const node = createNode(NODE_TYPES.FOLDER, folderName, folderPath);\r\n  graph.nodes.push(node);\r\n  nodeRegistry.folderNodes.set(folderPath, node);\r\n  const parentPath = path.dirname(folderPath);\r\n  if (parentPath !== folderPath) {\r\n    const parentNode = getOrCreateFolderNode(parentPath, graph, config);\r\n    graph.relationships.push(createRelationship(parentNode.id, node.id, REL_TYPES.CONTAINS));\r\n  }\r\n  if (config.captureContent) {\r\n    try {\r\n      const items = fs.readdirSync(folderPath);\r\n      const folderContent = items.map(item => {\r\n        const itemPath = path.join(folderPath, item);\r\n        const stats = fs.statSync(itemPath);\r\n        return {\r\n          name: item,\r\n          type: stats.isDirectory() ? 'folder' : 'file',\r\n          size: stats.size,\r\n          lastModified: stats.mtime\r\n        };\r\n      });\r\n      node.contentCount = folderContent.length;\r\n      node.contentSummary = `${folderContent.filter(i => i.type === 'folder').length} folders, ${folderContent.filter(i => i.type === 'file').length} files`;\r\n      registerContent(NODE_TYPES.FOLDER, folderName, folderContent, config);\r\n    } catch (error) {\r\n      console.error(`Error reading folder ${folderPath}:`, error.message);\r\n    }\r\n  }\r\n  return node;\r\n}"
    },
    {
      "id": "function-getOrCreateFileNode-helpers-L159",
      "type": "Function",
      "name": "getOrCreateFileNode",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 159,
          "column": 0
        },
        "end": {
          "line": 179,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function getOrCreateFileNode(filePath, graph, config) {\r\n  if (nodeRegistry.fileNodes.has(filePath)) return nodeRegistry.fileNodes.get(filePath);\r\n  const fileName = path.basename(filePath);\r\n  const node = createNode(NODE_TYPES.FILE, fileName, filePath);\r\n  graph.nodes.push(node);\r\n  nodeRegistry.fileNodes.set(filePath, node);\r\n  const folderPath = path.dirname(filePath);\r\n  const folderNode = getOrCreateFolderNode(folderPath, graph, config);\r\n  graph.relationships.push(createRelationship(folderNode.id, node.id, REL_TYPES.CONTAINS));\r\n  if (config.captureContent) {\r\n    try {\r\n      const fileContent = fs.readFileSync(filePath, 'utf-8');\r\n      node.fileSize = fileContent.length;\r\n      node.lineCount = fileContent.split('\\n').length;\r\n      registerContent(NODE_TYPES.FILE, fileName, fileContent, config);\r\n    } catch (error) {\r\n      console.error(`Error reading file ${filePath}:`, error.message);\r\n    }\r\n  }\r\n  return node;\r\n}"
    },
    {
      "id": "function-createEntityNode-helpers-L181",
      "type": "Function",
      "name": "createEntityNode",
      "filePath": "helpers.js",
      "location": {
        "start": {
          "line": 181,
          "column": 0
        },
        "end": {
          "line": 216,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function createEntityNode(type, name, filePath, loc, metadata = {}, sourceCode, graph, config) {\r\n  if (\r\n    (type === NODE_TYPES.VARIABLE && !config.includeVariables) ||\r\n    (type === NODE_TYPES.IMPORT && !config.includeImports) ||\r\n    (type === NODE_TYPES.CLASS && !config.includeClasses) ||\r\n    (type === NODE_TYPES.METHOD && !config.includeMethods) ||\r\n    (type === NODE_TYPES.FUNCTION && !config.includeFunctions)\r\n  ) {\r\n    return `placeholder_${type}_${name}`;\r\n  }\r\n  const key = `${filePath}:${type}:${name}:${loc.start.line}:${loc.start.column}`;\r\n  if (nodeRegistry.entityNodes.has(key)) return nodeRegistry.entityNodes.get(key);\r\n  if (config.captureContent && sourceCode) {\r\n    const codeContent = extractSourceCode(sourceCode, loc);\r\n    if (codeContent) {\r\n      metadata.codeScope = codeContent;\r\n      if (type === NODE_TYPES.CLASS || type === NODE_TYPES.METHOD) {\r\n        registerContent(type, name, codeContent, config);\r\n      }\r\n    }\r\n  }\r\n  const node = createNode(type, name, filePath, {\r\n    location: {\r\n      start: { line: loc.start.line, column: loc.start.column },\r\n      end: { line: loc.end.line, column: loc.end.column }\r\n    },\r\n    ...metadata\r\n  });\r\n  graph.nodes.push(node);\r\n  nodeRegistry.entityNodes.set(key, node);\r\n  const fileNode = getOrCreateFileNode(filePath, graph, config);\r\n  graph.relationships.push(createRelationship(fileNode.id, node.id, REL_TYPES.CONTAINS));\r\n  if (type === NODE_TYPES.CLASS) { globalContext.currentClassNode = node.id; }\r\n  else if (type === NODE_TYPES.METHOD) { globalContext.currentMethodNode = node.id; }\r\n  return node;\r\n}"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh",
      "type": "File",
      "name": "js-scanner.js",
      "filePath": "js-scanner.js",
      "fileSize": 35101,
      "lineCount": 981
    },
    {
      "id": "function-isPlaceholder-js_scanner-L40",
      "type": "Function",
      "name": "isPlaceholder",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 40,
          "column": 2
        },
        "end": {
          "line": 42,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function isPlaceholder(id) {\r\n    return typeof id === 'string' && id.startsWith('placeholder_');\r\n  }"
    },
    {
      "id": "function-isExternalLibrary-js_scanner-L54",
      "type": "Function",
      "name": "isExternalLibrary",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 54,
          "column": 2
        },
        "end": {
          "line": 57,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function isExternalLibrary(importPath) {\r\n    // Checks if the import path doesn't start with ./ or ../ or /\r\n    return !importPath.startsWith('.') && !importPath.startsWith('/');\r\n  }"
    },
    {
      "id": "function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "type": "Function",
      "name": "getOrCreateExternalLibraryNode",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 60,
          "column": 2
        },
        "end": {
          "line": 81,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function getOrCreateExternalLibraryNode(libraryName) {\r\n    if (externalLibraries.has(libraryName)) {\r\n      return externalLibraries.get(libraryName);\r\n    }\r\n    \r\n    // Extract the base library name (e.g., 'lodash' from 'lodash/map')\r\n    const baseLibName = libraryName.split('/')[0];\r\n    \r\n    // Check if we already have the base library\r\n    if (externalLibraries.has(baseLibName)) {\r\n      return externalLibraries.get(baseLibName);\r\n    }\r\n    \r\n    // Create new library node\r\n    const node = createNode(NODE_TYPES.EXTERNAL_LIBRARY, baseLibName, null, {\r\n      isExternal: true,\r\n      originalImport: libraryName\r\n    });\r\n    \r\n    externalLibraries.set(baseLibName, node);\r\n    return node;\r\n  }"
    },
    {
      "id": "function-generateMeaningfulId-js_scanner-L116",
      "type": "Function",
      "name": "generateMeaningfulId",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 116,
          "column": 2
        },
        "end": {
          "line": 207,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function generateMeaningfulId(type, name, filePath = null, location = null) {\r\n    // Clean up the name to use in the ID\r\n    const cleanName = name.replace(/[^a-zA-Z0-9_]/g, '_').substring(0, 40);\r\n    \r\n    // Base format: [type]-[name]\r\n    let id = `${type.toLowerCase()}-${cleanName}`;\r\n    \r\n    // Handle folder paths specially to avoid self-references\r\n    if (type === NODE_TYPES.FOLDER) {\r\n      // Special handling for root folders\r\n      if (filePath === '.' || filePath === './' || filePath === '\\\\') {\r\n        return 'folder-root';\r\n      }\r\n      \r\n      // For folders, add normalized path hash to ensure uniqueness\r\n      if (filePath) {\r\n        const folderName = path.basename(filePath);\r\n        const normalizedPath = path.normalize(filePath).replace(/\\\\/g, '/');\r\n        \r\n        if (folderName === '.' || folderName === '..') {\r\n          // Handle current/parent directory references\r\n          const pathSegments = normalizedPath.split('/').filter(Boolean);\r\n          const dirName = pathSegments.length > 0 ? pathSegments[pathSegments.length - 1] : 'root';\r\n          id = `folder-${dirName}-${Buffer.from(normalizedPath).toString('base64').substring(0, 8)}`;\r\n        } else {\r\n          // Normal folder - add path hash for uniqueness\r\n          id = `folder-${folderName.replace(/[^a-zA-Z0-9_]/g, '_')}-${Buffer.from(normalizedPath).toString('base64').substring(0, 8)}`;\r\n        }\r\n      }\r\n    } else if (type === NODE_TYPES.FILE) {\r\n      // For files, include normalized path hash for uniqueness\r\n      if (filePath) {\r\n        const filename = path.basename(filePath);\r\n        const normalizedPath = path.normalize(filePath).replace(/\\\\/g, '/');\r\n        id = `file-${filename.replace(/[^a-zA-Z0-9_.]/g, '_')}-${Buffer.from(normalizedPath).toString('base64').substring(0, 8)}`;\r\n      }\r\n    } else if (type === NODE_TYPES.CLASS) {\r\n      // Classes should include file path to ensure uniqueness\r\n      if (filePath) {\r\n        const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n        id = `class-${cleanName}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n        \r\n        // Add location info for extra uniqueness if available\r\n        if (location) {\r\n          id += `-L${location.start.line}`;\r\n        }\r\n      }\r\n    } else if (type === NODE_TYPES.METHOD) {\r\n      // Methods need class context and file for uniqueness\r\n      if (filePath) {\r\n        const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n        // Use class context when available\r\n        const classContext = global.currentClassContext || '';\r\n        id = `method-${cleanName}-${classContext}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n        \r\n        // Add location info for extra uniqueness\r\n        if (location) {\r\n          id += `-L${location.start.line}`;\r\n        }\r\n      }\r\n    } else if (type === NODE_TYPES.FUNCTION) {\r\n      // Functions need file context for uniqueness\r\n      if (filePath) {\r\n        const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n        id = `function-${cleanName}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n        \r\n        // Add location info for uniqueness\r\n        if (location) {\r\n          id += `-L${location.start.line}`;\r\n        }\r\n      }\r\n    } else if (type === NODE_TYPES.VARIABLE) {\r\n      // Variables need scope and file context\r\n      if (filePath) {\r\n        const filename = path.basename(filePath).replace(/\\.[^/.]+$/, \"\");\r\n        const scopeContext = global.currentScopeContext || '';\r\n        id = `variable-${cleanName}-${scopeContext}-${filename.replace(/[^a-zA-Z0-9_]/g, '_')}`;\r\n        \r\n        if (location) {\r\n          id += `-L${location.start.line}`;\r\n        }\r\n      }\r\n    } else if (type === NODE_TYPES.EXTERNAL_LIBRARY) {\r\n      // External libraries - add version info if available\r\n      const version = global.packageVersions && global.packageVersions[name] \r\n        ? `-${global.packageVersions[name].replace(/[^a-zA-Z0-9_.]/g, '_')}`\r\n        : '';\r\n      id = `lib-${cleanName}${version}`;\r\n    }\r\n    \r\n    return id;\r\n  }"
    },
    {
      "id": "function-createNode-js_scanner-L210",
      "type": "Function",
      "name": "createNode",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 210,
          "column": 2
        },
        "end": {
          "line": 224,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function createNode(type, name, filePath = null, metadata = {}) {\r\n    const location = metadata.location || null;\r\n    const id = generateMeaningfulId(type, name, filePath, location);\r\n    \r\n    const node = {\r\n      id,\r\n      type,\r\n      name,\r\n      filePath,\r\n      ...metadata\r\n    };\r\n    \r\n    graph.nodes.push(node);\r\n    return node;\r\n  }"
    },
    {
      "id": "function-createRelationship-js_scanner-L227",
      "type": "Function",
      "name": "createRelationship",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 227,
          "column": 2
        },
        "end": {
          "line": 238,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function createRelationship(sourceId, targetId, type, metadata = {}) {\r\n    const relationship = {\r\n      id: `${sourceId}-${type}-${targetId}`,  // Changed: use a concatenated id\r\n      source: sourceId,\r\n      target: targetId,\r\n      type,\r\n      ...metadata\r\n    };\r\n    \r\n    graph.relationships.push(relationship);\r\n    return relationship;\r\n  }"
    },
    {
      "id": "function-registerContent-js_scanner-L241",
      "type": "Function",
      "name": "registerContent",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 241,
          "column": 2
        },
        "end": {
          "line": 268,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function registerContent(type, name, content) {\r\n    if (!config.captureContent) return;\r\n    \r\n    let registry;\r\n    switch (type) {\r\n      case NODE_TYPES.FOLDER:\r\n        registry = contentRegistry.folderContents;\r\n        break;\r\n      case NODE_TYPES.FILE:\r\n        registry = contentRegistry.fileContents;\r\n        break;\r\n      case NODE_TYPES.CLASS:\r\n        registry = contentRegistry.classScopes;\r\n        break;\r\n      case NODE_TYPES.METHOD:\r\n        registry = contentRegistry.methodScopes;\r\n        break;\r\n      default:\r\n        return; // Don't register for other types\r\n    }\r\n    \r\n    // Add content to registry\r\n    if (registry.has(name)) {\r\n      registry.get(name).push(content);\r\n    } else {\r\n      registry.set(name, [content]);\r\n    }\r\n  }"
    },
    {
      "id": "function-getOrCreateFolderNode-js_scanner-L271",
      "type": "Function",
      "name": "getOrCreateFolderNode",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 271,
          "column": 2
        },
        "end": {
          "line": 316,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function getOrCreateFolderNode(folderPath) {\r\n    if (nodeRegistry.folderNodes.has(folderPath)) {\r\n      return nodeRegistry.folderNodes.get(folderPath);\r\n    }\r\n    \r\n    const folderName = path.basename(folderPath);\r\n    // Clean and ensure uniqueness by including path hash\r\n    const node = createNode(NODE_TYPES.FOLDER, folderName, folderPath);\r\n    nodeRegistry.folderNodes.set(folderPath, node);\r\n    \r\n    // Create relationship with parent folder\r\n    const parentPath = path.dirname(folderPath);\r\n    if (parentPath !== folderPath) {\r\n      const parentNode = getOrCreateFolderNode(parentPath);\r\n      createRelationship(parentNode.id, node.id, REL_TYPES.CONTAINS);\r\n    }\r\n    \r\n    // Register folder content if config allows\r\n    if (config.captureContent) {\r\n      try {\r\n        // Get list of files/folders in this directory\r\n        const items = fs.readdirSync(folderPath);\r\n        const folderContent = items.map(item => {\r\n          const itemPath = path.join(folderPath, item);\r\n          const stats = fs.statSync(itemPath);\r\n          return {\r\n            name: item,\r\n            type: stats.isDirectory() ? 'folder' : 'file',\r\n            size: stats.size,\r\n            lastModified: stats.mtime\r\n          };\r\n        });\r\n        \r\n        // Update node with folder contents\r\n        node.contentCount = folderContent.length;\r\n        node.contentSummary = `${folderContent.filter(i => i.type === 'folder').length} folders, ${folderContent.filter(i => i.type === 'file').length} files`;\r\n        \r\n        // Register content in content registry\r\n        registerContent(NODE_TYPES.FOLDER, folderName, folderContent);\r\n      } catch (error) {\r\n        console.error(`Error reading folder contents for ${folderPath}:`, error.message);\r\n      }\r\n    }\r\n    \r\n    return node;\r\n  }"
    },
    {
      "id": "function-getOrCreateFileNode-js_scanner-L319",
      "type": "Function",
      "name": "getOrCreateFileNode",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 319,
          "column": 2
        },
        "end": {
          "line": 348,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function getOrCreateFileNode(filePath) {\r\n    if (nodeRegistry.fileNodes.has(filePath)) {\r\n      return nodeRegistry.fileNodes.get(filePath);\r\n    }\r\n    \r\n    const fileName = path.basename(filePath);\r\n    const node = createNode(NODE_TYPES.FILE, fileName, filePath);\r\n    nodeRegistry.fileNodes.set(filePath, node);\r\n    \r\n    // Create relationship with containing folder\r\n    const folderPath = path.dirname(filePath);\r\n    const folderNode = getOrCreateFolderNode(folderPath);\r\n    createRelationship(folderNode.id, node.id, REL_TYPES.CONTAINS);\r\n    \r\n    // Register file content if config allows\r\n    if (config.captureContent) {\r\n      try {\r\n        const fileContent = fs.readFileSync(filePath, 'utf-8');\r\n        node.fileSize = fileContent.length;\r\n        node.lineCount = fileContent.split('\\n').length;\r\n        \r\n        // Register content in content registry\r\n        registerContent(NODE_TYPES.FILE, fileName, fileContent);\r\n      } catch (error) {\r\n        console.error(`Error reading file content for ${filePath}:`, error.message);\r\n      }\r\n    }\r\n    \r\n    return node;\r\n  }"
    },
    {
      "id": "function-extractSourceCode-js_scanner-L351",
      "type": "Function",
      "name": "extractSourceCode",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 351,
          "column": 2
        },
        "end": {
          "line": 380,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function extractSourceCode(sourceCode, loc) {\r\n    if (!sourceCode || !loc) return '';\r\n    \r\n    try {\r\n      const lines = sourceCode.split('\\n');\r\n      const startLine = loc.start.line - 1;\r\n      const endLine = loc.end.line - 1;\r\n      \r\n      if (startLine === endLine) {\r\n        return lines[startLine].substring(loc.start.column, loc.end.column);\r\n      } else {\r\n        const codeLines = [];\r\n        // First line from start column to end\r\n        codeLines.push(lines[startLine].substring(loc.start.column));\r\n        \r\n        // Middle lines (if any)\r\n        for (let i = startLine + 1; i < endLine; i++) {\r\n          codeLines.push(lines[i]);\r\n        }\r\n        \r\n        // Last line from beginning to end column\r\n        codeLines.push(lines[endLine].substring(0, loc.end.column));\r\n        \r\n        return codeLines.join('\\n');\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error extracting source code:`, error.message);\r\n      return '';\r\n    }\r\n  }"
    },
    {
      "id": "function-createEntityNode-js_scanner-L383",
      "type": "Function",
      "name": "createEntityNode",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 383,
          "column": 2
        },
        "end": {
          "line": 437,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function createEntityNode(type, name, filePath, loc, metadata = {}, sourceCode = null) {\r\n    // Check if this type of node should be included based on configuration\r\n    if (\r\n      (type === NODE_TYPES.VARIABLE && !config.includeVariables) ||\r\n      (type === NODE_TYPES.IMPORT && !config.includeImports) ||\r\n      (type === NODE_TYPES.CLASS && !config.includeClasses) ||\r\n      (type === NODE_TYPES.METHOD && !config.includeMethods) ||\r\n      (type === NODE_TYPES.FUNCTION && !config.includeFunctions)\r\n    ) {\r\n      // Return a placeholder id as string for tracking in scope but not in actual graph\r\n      return `placeholder_${type}_${name}`;\r\n    }\r\n    \r\n    const key = `${filePath}:${type}:${name}:${loc.start.line}:${loc.start.column}`;\r\n    \r\n    if (nodeRegistry.entityNodes.has(key)) {\r\n      return nodeRegistry.entityNodes.get(key);\r\n    }\r\n    \r\n    // Add code scope content if provided\r\n    if (config.captureContent && sourceCode) {\r\n      const codeContent = extractSourceCode(sourceCode, loc);\r\n      if (codeContent) {\r\n        metadata.codeScope = codeContent;\r\n        \r\n        // Register content in appropriate registry\r\n        if (type === NODE_TYPES.CLASS || type === NODE_TYPES.METHOD) {\r\n          registerContent(type, name, codeContent);\r\n        }\r\n      }\r\n    }\r\n    \r\n    const node = createNode(type, name, filePath, {\r\n      location: {\r\n        start: { line: loc.start.line, column: loc.start.column },\r\n        end: { line: loc.end.line, column: loc.end.column }\r\n      },\r\n      ...metadata\r\n    });\r\n    \r\n    nodeRegistry.entityNodes.set(key, node);\r\n    \r\n    // Create relationship with containing file\r\n    const fileNode = getOrCreateFileNode(filePath);\r\n    createRelationship(fileNode.id, node.id, REL_TYPES.CONTAINS);\r\n    \r\n    // Update global tracking for class and method contexts\r\n    if (type === NODE_TYPES.CLASS) {\r\n      global.currentClassNode = node.id;\r\n    } else if (type === NODE_TYPES.METHOD) {\r\n      global.currentMethodNode = node.id;\r\n    }\r\n    \r\n    return node;\r\n  }"
    },
    {
      "id": "function-analyzeFile-js_scanner-L440",
      "type": "Function",
      "name": "analyzeFile",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 440,
          "column": 2
        },
        "end": {
          "line": 715,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function analyzeFile(filePath) {\r\n    console.log(`Analyzing file: ${filePath}`);\r\n    const fileNode = getOrCreateFileNode(filePath);\r\n    \r\n    // Reset global context for this file\r\n    global.currentClassContext = null;\r\n    global.currentMethodContext = null;\r\n    global.currentScopeContext = null;\r\n    global.currentClassNode = null;\r\n    global.currentMethodNode = null;\r\n    \r\n    try {\r\n      const code = fs.readFileSync(filePath, 'utf-8');\r\n      \r\n      // Parse the code\r\n      const ast = parser.parse(code, {\r\n        sourceType: 'module',\r\n        plugins: ['jsx', 'typescript', 'classProperties', 'decorators-legacy']\r\n      });\r\n      \r\n      // Track scope for variable references\r\n      const scopeTracker = {\r\n        currentClass: null,\r\n        currentMethod: null,\r\n        declaredVariables: new Map(),\r\n        importedModules: new Map()\r\n      };\r\n      \r\n      // Traverse the AST\r\n      traverse(ast, {\r\n        ImportDeclaration(path) {\r\n          const importSource = path.node.source.value;\r\n          \r\n          if (config.trackExternalLibraries && isExternalLibrary(importSource)) {\r\n            // Handle external library import\r\n            const libraryNode = getOrCreateExternalLibraryNode(importSource);\r\n            createRelationship(fileNode.id, libraryNode.id, REL_TYPES.IMPORTS);\r\n            \r\n            // Track imported specifiers\r\n            path.node.specifiers.forEach(specifier => {\r\n              const importedName = specifier.local.name;\r\n              scopeTracker.importedModules.set(importedName, libraryNode.id);\r\n            });\r\n          } else {\r\n            // Handle internal module import\r\n            const importNode = createEntityNode(\r\n              NODE_TYPES.IMPORT, \r\n              importSource, \r\n              filePath, \r\n              path.node.loc,\r\n              {},\r\n              code\r\n            );\r\n            \r\n            createRelationship(fileNode.id, importNode.id, REL_TYPES.IMPORTS);\r\n            \r\n            // Track imported specifiers\r\n            path.node.specifiers.forEach(specifier => {\r\n              const importedName = specifier.local.name;\r\n              scopeTracker.importedModules.set(importedName, importNode.id);\r\n            });\r\n          }\r\n        },\r\n        \r\n        ClassDeclaration(path) {\r\n          const className = path.node.id.name;\r\n          const classNode = createEntityNode(\r\n            NODE_TYPES.CLASS, \r\n            className, \r\n            filePath, \r\n            path.node.loc,\r\n            {},\r\n            code\r\n          );\r\n          \r\n          // Update global context\r\n          global.currentClassContext = className;\r\n          \r\n          // Track for nested methods\r\n          scopeTracker.currentClass = classNode.id;\r\n          \r\n          // Handle class extensions\r\n          if (path.node.superClass) {\r\n            const superClassName = path.node.superClass.name;\r\n            if (scopeTracker.importedModules.has(superClassName)) {\r\n              createRelationship(\r\n                classNode.id, \r\n                scopeTracker.importedModules.get(superClassName),\r\n                REL_TYPES.EXTENDS\r\n              );\r\n            }\r\n          }\r\n        },\r\n        \r\n        ClassMethod(path) {\r\n          if (!scopeTracker.currentClass) return;\r\n          \r\n          const methodName = path.node.key.name;\r\n          const methodNode = createEntityNode(\r\n            NODE_TYPES.METHOD, \r\n            methodName, \r\n            filePath, \r\n            path.node.loc,\r\n            { \r\n              isAsync: path.node.async, \r\n              isGenerator: path.node.generator,\r\n              parentClass: global.currentClassContext\r\n            },\r\n            code\r\n          );\r\n          \r\n          // Update method context\r\n          global.currentMethodContext = methodName;\r\n          global.currentScopeContext = `${global.currentClassContext}.${methodName}`;\r\n          \r\n          createRelationship(\r\n            scopeTracker.currentClass, \r\n            methodNode.id, \r\n            REL_TYPES.CONTAINS\r\n          );\r\n          \r\n          // Track current method for variable scope\r\n          scopeTracker.currentMethod = methodNode.id;\r\n        },\r\n        \r\n        FunctionDeclaration(path) {\r\n          const funcName = path.node.id.name;\r\n          const funcNode = createEntityNode(\r\n            NODE_TYPES.FUNCTION, \r\n            funcName, \r\n            filePath, \r\n            path.node.loc,\r\n            { \r\n              isAsync: path.node.async, \r\n              isGenerator: path.node.generator\r\n            },\r\n            code\r\n          );\r\n          \r\n          // Update context\r\n          global.currentMethodContext = null;\r\n          global.currentScopeContext = funcName;\r\n          \r\n          // Add to scope\r\n          scopeTracker.declaredVariables.set(funcName, funcNode.id);\r\n        },\r\n        \r\n        VariableDeclarator(path) {\r\n          const varName = path.node.id.name;\r\n          const varNode = createEntityNode(\r\n            NODE_TYPES.VARIABLE, \r\n            varName, \r\n            filePath, \r\n            path.node.loc,\r\n            {},\r\n            code\r\n          );\r\n          \r\n          // Track in current scope\r\n          scopeTracker.declaredVariables.set(varName, varNode.id);\r\n          \r\n          // If variable is initialized, create reference relationship\r\n          if (path.node.init) {\r\n            if (path.node.init.type === 'CallExpression') {\r\n              const calleeName = path.node.init.callee.name;\r\n              if (scopeTracker.declaredVariables.has(calleeName)) {\r\n                createRelationship(\r\n                  varNode.id,\r\n                  scopeTracker.declaredVariables.get(calleeName),\r\n                  REL_TYPES.CALLS\r\n                );\r\n              }\r\n            } else if (path.node.init.type === 'Identifier') {\r\n              const initName = path.node.init.name;\r\n              if (scopeTracker.declaredVariables.has(initName)) {\r\n                createRelationship(\r\n                  varNode.id,\r\n                  scopeTracker.declaredVariables.get(initName),\r\n                  REL_TYPES.REFERENCES\r\n                );\r\n              }\r\n            }\r\n          }\r\n          \r\n          // Connect to parent scope\r\n          if (scopeTracker.currentMethod) {\r\n            createRelationship(\r\n              scopeTracker.currentMethod, \r\n              varNode.id, \r\n              REL_TYPES.DECLARES\r\n            );\r\n          } else if (scopeTracker.currentClass) {\r\n            createRelationship(\r\n              scopeTracker.currentClass, \r\n              varNode.id, \r\n              REL_TYPES.DECLARES\r\n            );\r\n          }\r\n        },\r\n        \r\n        // Track scope changes\r\n        BlockStatement: {\r\n          enter(path) {\r\n            // Save parent scope\r\n            path.node._parentScope = global.currentScopeContext;\r\n          },\r\n          exit(path) {\r\n            // Restore parent scope\r\n            global.currentScopeContext = path.node._parentScope;\r\n          }\r\n        },\r\n        \r\n        MemberExpression(path) {\r\n          // Track object property references\r\n          if (path.node.object.type === 'ThisExpression' && scopeTracker.currentClass) {\r\n            // Reference to class property\r\n            if (path.node.property.type === 'Identifier') {\r\n              const propertyName = path.node.property.name;\r\n              // We could create nodes for these, but for now just track the reference\r\n            }\r\n          }\r\n        },\r\n        \r\n        // Handle require calls\r\n        CallExpression(path) {\r\n          // Track function calls\r\n          if (path.node.callee.type === 'Identifier') {\r\n            const calleeName = path.node.callee.name;\r\n            \r\n            // Handle require statements\r\n            if (calleeName === 'require' && \r\n                path.node.arguments.length > 0 && \r\n                path.node.arguments[0].type === 'StringLiteral') {\r\n              \r\n              const requirePath = path.node.arguments[0].value;\r\n              \r\n              if (config.trackExternalLibraries && isExternalLibrary(requirePath)) {\r\n                // Handle external library require\r\n                const libraryNode = getOrCreateExternalLibraryNode(requirePath);\r\n                createRelationship(fileNode.id, libraryNode.id, REL_TYPES.IMPORTS);\r\n                \r\n                // If this is part of a variable declaration, track the variable\r\n                const parentPath = path.parentPath;\r\n                if (parentPath && parentPath.node.type === 'VariableDeclarator') {\r\n                  const varName = parentPath.node.id.name;\r\n                  scopeTracker.importedModules.set(varName, libraryNode.id);\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Regular function calls\r\n            if (scopeTracker.declaredVariables.has(calleeName)) {\r\n              // Create a relationship from current scope to the called function\r\n              let sourceId;\r\n              if (scopeTracker.currentMethod) {\r\n                sourceId = scopeTracker.currentMethod;\r\n              } else if (scopeTracker.currentClass) {\r\n                sourceId = scopeTracker.currentClass;\r\n              } else {\r\n                sourceId = fileNode.id;\r\n              }\r\n              \r\n              createRelationship(\r\n                sourceId,\r\n                scopeTracker.declaredVariables.get(calleeName),\r\n                REL_TYPES.CALLS\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n      \r\n    } catch (error) {\r\n      console.error(`Error analyzing file ${filePath}:`, error.message);\r\n    }\r\n  }"
    },
    {
      "id": "function-scanDirectory-js_scanner-L718",
      "type": "Function",
      "name": "scanDirectory",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 718,
          "column": 2
        },
        "end": {
          "line": 741,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function scanDirectory(dirPath) {\r\n    // Skip node_modules if configured to do so\r\n    if (config.ignoreNodeModules && dirPath.includes('node_modules')) {\r\n      return;\r\n    }\r\n  \r\n    console.log(`Scanning directory: ${dirPath}`);\r\n    const items = fs.readdirSync(dirPath);\r\n    \r\n    for (const item of items) {\r\n      const itemPath = path.join(dirPath, item);\r\n      const stats = fs.statSync(itemPath);\r\n      \r\n      if (stats.isDirectory()) {\r\n        // Skip node_modules if configured\r\n        if (config.ignoreNodeModules && item === 'node_modules') {\r\n          continue;\r\n        }\r\n        scanDirectory(itemPath);\r\n      } else if (stats.isFile() && /\\.(js|jsx|ts|tsx)$/.test(itemPath)) {\r\n        analyzeFile(itemPath);\r\n      }\r\n    }\r\n  }"
    },
    {
      "id": "function-scanJSService-js_scanner-L744",
      "type": "Function",
      "name": "scanJSService",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 744,
          "column": 2
        },
        "end": {
          "line": 798,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function scanJSService(rootPath, customConfig = {}) {\r\n    // Apply custom configuration\r\n    config = { ...defaultConfig, ...customConfig };\r\n    console.log(`Starting scan of JS service at: ${rootPath}`);\r\n    console.log(`Configuration: ${JSON.stringify(config, null, 2)}`);\r\n    \r\n    // Clear previous data\r\n    graph.nodes = [];\r\n    graph.relationships = [];\r\n    nodeRegistry.folderNodes.clear();\r\n    nodeRegistry.fileNodes.clear();\r\n    nodeRegistry.entityNodes.clear();\r\n    externalLibraries.clear();\r\n    \r\n    // Clear content registries\r\n    contentRegistry.folderContents.clear();\r\n    contentRegistry.fileContents.clear();\r\n    contentRegistry.classScopes.clear();\r\n    contentRegistry.methodScopes.clear();\r\n    \r\n    // Try to find and parse package.json to identify project dependencies\r\n    try {\r\n      const packageJsonPath = path.join(rootPath, 'package.json');\r\n      if (fs.existsSync(packageJsonPath)) {\r\n        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));\r\n        \r\n        // Pre-register all dependencies as external libraries\r\n        const dependencies = {\r\n          ...packageJson.dependencies || {},\r\n          ...packageJson.devDependencies || {}\r\n        };\r\n        \r\n        for (const [libName, version] of Object.entries(dependencies)) {\r\n          const node = createNode(NODE_TYPES.EXTERNAL_LIBRARY, libName, null, {\r\n            isExternal: true,\r\n            version: version,\r\n            fromPackageJson: true\r\n          });\r\n          externalLibraries.set(libName, node);\r\n        }\r\n        \r\n        console.log(`Found ${externalLibraries.size} dependencies in package.json`);\r\n      }\r\n    } catch (error) {\r\n      console.error(`Error parsing package.json:`, error.message);\r\n    }\r\n    \r\n    // Initialize root folder\r\n    getOrCreateFolderNode(rootPath);\r\n    \r\n    // Scan the directory\r\n    scanDirectory(rootPath);\r\n    \r\n    return graph;\r\n  }"
    },
    {
      "id": "function-getContentListsByName-js_scanner-L801",
      "type": "Function",
      "name": "getContentListsByName",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 801,
          "column": 2
        },
        "end": {
          "line": 821,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function getContentListsByName(name, type) {\r\n    let registry;\r\n    switch (type) {\r\n      case NODE_TYPES.FOLDER:\r\n        registry = contentRegistry.folderContents;\r\n        break;\r\n      case NODE_TYPES.FILE:\r\n        registry = contentRegistry.fileContents;\r\n        break;\r\n      case NODE_TYPES.CLASS:\r\n        registry = contentRegistry.classScopes;\r\n        break;\r\n      case NODE_TYPES.METHOD:\r\n        registry = contentRegistry.methodScopes;\r\n        break;\r\n      default:\r\n        return null;\r\n    }\r\n    \r\n    return registry.has(name) ? registry.get(name) : [];\r\n  }"
    },
    {
      "id": "function-exportToNeo4j-js_scanner-L824",
      "type": "Function",
      "name": "exportToNeo4j",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 824,
          "column": 0
        },
        "end": {
          "line": 917,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function exportToNeo4j() {\r\n    // Filter out any invalid relationships\r\n    const validRelationships = graph.relationships.filter(rel => {\r\n      if (!rel.source || !rel.target || isPlaceholder(rel.source) || isPlaceholder(rel.target)) {\r\n        return false;\r\n      }\r\n      const sourceExists = graph.nodes.some(node => node.id === rel.source);\r\n      const targetExists = graph.nodes.some(node => node.id === rel.target);\r\n      return sourceExists && targetExists;\r\n    });\r\n  \r\n    // Create constraints and indexes for better performance\r\n    const constraints = [\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Folder) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:File) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Class) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Method) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Function) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Variable) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:Import) REQUIRE n.id IS UNIQUE',\r\n      'CREATE CONSTRAINT IF NOT EXISTS FOR (n:ExternalLibrary) REQUIRE n.id IS UNIQUE',\r\n      'CREATE INDEX IF NOT EXISTS FOR (n:Folder) ON (n.name)',\r\n      'CREATE INDEX IF NOT EXISTS FOR (n:File) ON (n.name)',\r\n    ].join(';\\n');\r\n  \r\n    // Create Cypher queries for nodes using MERGE to avoid duplicates\r\n    const nodesQuery = graph.nodes.map(node => {\r\n      // Clone properties and remove the internal id property from the props\r\n      const props = { ...node };\r\n      delete props.id;\r\n      \r\n      // Add content lists if applicable\r\n      if (config.captureContent) {\r\n        if ([NODE_TYPES.FOLDER, NODE_TYPES.FILE, NODE_TYPES.CLASS, NODE_TYPES.METHOD].includes(node.type)) {\r\n          const contentLists = getContentListsByName(node.name, node.type);\r\n          if (contentLists && contentLists.length > 0) {\r\n            props.contentLists = contentLists;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Build property string, converting complex objects to JSON strings\r\n      const propEntries = Object.entries(props)\r\n        .filter(([_, v]) => v !== null && v !== undefined)\r\n        .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)\r\n        .join(', ');\r\n      \r\n      // Use MERGE to prevent duplicates, with the id as the unique key\r\n      return `MERGE (n:${node.type} {id: ${JSON.stringify(node.id)}})  ON CREATE SET n.name = ${JSON.stringify(node.name)}, ${propEntries}`;\r\n    }).join(';\\n');\r\n  \r\n    // Create Cypher queries for relationships using node IDs for matching\r\n    const relsQuery = validRelationships.map(rel => {\r\n      // Look up source and target nodes in the graph by their generated id\r\n      const sourceNode = graph.nodes.find(node => node.id === rel.source);\r\n      const targetNode = graph.nodes.find(node => node.id === rel.target);\r\n      \r\n      // Skip if source or target is missing or if it's a self-reference\r\n      if (!sourceNode || !targetNode || sourceNode.id === targetNode.id) {\r\n        console.log(`Skipping invalid relationship: ${rel.id} (${rel.source} -> ${rel.target})`);\r\n        return '';\r\n      }\r\n      \r\n      // Check for unique source/target pair to avoid duplicate relationships\r\n      return `MATCH (a:${sourceNode.type} {id: ${JSON.stringify(sourceNode.id)}}), (b:${targetNode.type} {id: ${JSON.stringify(targetNode.id)}})  WHERE a <> b // Ensure we're not creating self-relationships  MERGE (a)-[r:${rel.type}]->(b)  ON CREATE SET r.id = ${JSON.stringify(rel.id)}`;\r\n    }).filter(Boolean).join(';\\n');\r\n  \r\n    // Summary statistics to add as a comment\r\n    const stats = `// Export summary:\r\n  // - ${graph.nodes.length} nodes\r\n  // - ${validRelationships.length} relationships\r\n  // - ${new Set(graph.nodes.map(n => n.type)).size} node types\r\n  // - ${new Set(validRelationships.map(r => r.type)).size} relationship types\r\n  // Exported on: ${new Date().toISOString()}`;\r\n  \r\n    // Wrap everything in a transaction block\r\n    const transactionStart = 'BEGIN';\r\n    const transactionEnd = 'COMMIT';\r\n    \r\n    return `${stats}\r\n  \r\n  ${transactionStart};\r\n  \r\n  // Create constraints and indexes\r\n  ${constraints};\r\n  \r\n  // Create nodes\r\n  ${nodesQuery};\r\n  \r\n  // Create relationships\r\n  ${relsQuery};\r\n  \r\n  ${transactionEnd};`;\r\n  }"
    },
    {
      "id": "function-exportToJSON-js_scanner-L920",
      "type": "Function",
      "name": "exportToJSON",
      "filePath": "js-scanner.js",
      "location": {
        "start": {
          "line": 920,
          "column": 2
        },
        "end": {
          "line": 965,
          "column": 3
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function exportToJSON(filePath) {\r\n    // Filter out any invalid relationships\r\n    const validRelationships = graph.relationships.filter(rel => {\r\n      // Skip if source or target is null, undefined or a placeholder\r\n      if (!rel.source || !rel.target || isPlaceholder(rel.source) || isPlaceholder(rel.target)) {\r\n        return false;\r\n      }\r\n      \r\n      // Skip if source or target node doesn't exist in the graph\r\n      const sourceExists = graph.nodes.some(node => node.id === rel.source);\r\n      const targetExists = graph.nodes.some(node => node.id === rel.target);\r\n      \r\n      return sourceExists && targetExists;\r\n    });\r\n    \r\n    // Enhance nodes with content lists\r\n    const enhancedNodes = graph.nodes.map(node => {\r\n      const enhancedNode = {...node};\r\n      \r\n      // Add content lists for applicable node types\r\n      if (config.captureContent) {\r\n        if ([NODE_TYPES.FOLDER, NODE_TYPES.FILE, NODE_TYPES.CLASS, NODE_TYPES.METHOD].includes(node.type)) {\r\n          const contentLists = getContentListsByName(node.name, node.type);\r\n          if (contentLists && contentLists.length > 0) {\r\n            enhancedNode.contentLists = contentLists;\r\n          }\r\n        }\r\n      }\r\n      \r\n      return enhancedNode;\r\n    });\r\n    \r\n    const cleanedGraph = {\r\n      nodes: enhancedNodes,\r\n      relationships: validRelationships,\r\n      contentRegistrySummary: {\r\n        folders: contentRegistry.folderContents.size,\r\n        files: contentRegistry.fileContents.size,\r\n        classes: contentRegistry.classScopes.size,\r\n        methods: contentRegistry.methodScopes.size\r\n      }\r\n    };\r\n    \r\n    fs.writeFileSync(filePath, JSON.stringify(cleanedGraph, null, 2));\r\n    console.log(`Graph exported to ${filePath}`);\r\n  }"
    },
    {
      "id": "file-main.js-bWFpbi5q",
      "type": "File",
      "name": "main.js",
      "filePath": "main.js",
      "fileSize": 4148,
      "lineCount": 113
    },
    {
      "id": "file-scanner.js-c2Nhbm5l",
      "type": "File",
      "name": "scanner.js",
      "filePath": "scanner.js",
      "fileSize": 3091,
      "lineCount": 84
    },
    {
      "id": "function-scanDirectory-scanner-L14",
      "type": "Function",
      "name": "scanDirectory",
      "filePath": "scanner.js",
      "location": {
        "start": {
          "line": 14,
          "column": 0
        },
        "end": {
          "line": 28,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function scanDirectory(dirPath, graph, config) {\r\n    if (config.ignoreNodeModules && dirPath.includes('node_modules')) return;\r\n    console.log(`Scanning directory: ${dirPath}`);\r\n    const items = fs.readdirSync(dirPath);\r\n    items.forEach(item => {\r\n        const itemPath = path.join(dirPath, item);\r\n        const stats = fs.statSync(itemPath);\r\n        if (stats.isDirectory()) {\r\n            if (config.ignoreNodeModules && item === 'node_modules') return;\r\n            scanDirectory(itemPath, graph, config);\r\n        } else if (stats.isFile() && /\\.(js|jsx|ts|tsx)$/.test(itemPath)) {\r\n            analyzeFile(itemPath, graph, config);\r\n        }\r\n    });\r\n}"
    },
    {
      "id": "function-scanJSService-scanner-L30",
      "type": "Function",
      "name": "scanJSService",
      "filePath": "scanner.js",
      "location": {
        "start": {
          "line": 30,
          "column": 0
        },
        "end": {
          "line": 81,
          "column": 1
        }
      },
      "isAsync": false,
      "isGenerator": false,
      "codeScope": "function scanJSService(rootPath, customConfig = {}) {\r\n    const config = { ...defaultConfig, ...customConfig };\r\n    console.log(`Starting scan of JS service at: ${rootPath}`);\r\n    console.log(`Configuration: ${JSON.stringify(config, null, 2)}`);\r\n\r\n    // Graph structure\r\n    const graph = { nodes: [], relationships: [] };\r\n\r\n    // Clear existing registries if needed\r\n    // ...existing registry clearing logic using Map.clear()...\r\n    // Clear previous data\r\n    graph.nodes = [];\r\n    graph.relationships = [];\r\n    nodeRegistry.folderNodes.clear();\r\n    nodeRegistry.fileNodes.clear();\r\n    nodeRegistry.entityNodes.clear();\r\n    externalLibraries.clear();\r\n\r\n    // Clear content registries\r\n    contentRegistry.folderContents.clear();\r\n    contentRegistry.fileContents.clear();\r\n    contentRegistry.classScopes.clear();\r\n    contentRegistry.methodScopes.clear();\r\n\r\n    // Initialize root folder node\r\n    getOrCreateFolderNode(rootPath, graph, config);\r\n\r\n    // Parse package.json for dependencies (optional)\r\n    try {\r\n        const packageJsonPath = path.join(rootPath, 'package.json');\r\n        if (fs.existsSync(packageJsonPath)) {\r\n            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));\r\n            const dependencies = { ...(packageJson.dependencies || {}), ...(packageJson.devDependencies || {}) };\r\n            Object.entries(dependencies).forEach(([libName, version]) => {\r\n                // Create external library node and register it\r\n                const node = createNode(NODE_TYPES.EXTERNAL_LIBRARY, libName, null, {\r\n                    isExternal: true,\r\n                    version: version,\r\n                    fromPackageJson: true\r\n                });\r\n                externalLibraries.set(libName, node);\r\n            });\r\n            console.log(`Found dependencies in package.json`);\r\n        }\r\n    } catch (error) {\r\n        console.error('Error parsing package.json:', error.message);\r\n    }\r\n\r\n    // Start scanning\r\n    scanDirectory(rootPath, graph, config);\r\n    return graph;\r\n}"
    }
  ],
  "relationships": [
    {
      "id": "folder-_-Lg==-CONTAINS-folder-_-Li8=",
      "source": "folder-_-Lg==",
      "target": "folder-_-Li8=",
      "type": "CONTAINS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-ast.js-YXN0Lmpz",
      "source": "folder-_-Lg==",
      "target": "file-ast.js-YXN0Lmpz",
      "type": "CONTAINS"
    },
    {
      "id": "file-ast.js-YXN0Lmpz-CONTAINS-function-analyzeFile-ast-L15",
      "source": "file-ast.js-YXN0Lmpz",
      "target": "function-analyzeFile-ast-L15",
      "type": "CONTAINS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-constants.js-Y29uc3Rh",
      "source": "folder-_-Lg==",
      "target": "file-constants.js-Y29uc3Rh",
      "type": "CONTAINS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-exporters.js-ZXhwb3J0",
      "source": "folder-_-Lg==",
      "target": "file-exporters.js-ZXhwb3J0",
      "type": "CONTAINS"
    },
    {
      "id": "file-exporters.js-ZXhwb3J0-CONTAINS-function-exportToNeo4j-exporters-L4",
      "source": "file-exporters.js-ZXhwb3J0",
      "target": "function-exportToNeo4j-exporters-L4",
      "type": "CONTAINS"
    },
    {
      "id": "file-exporters.js-ZXhwb3J0-CONTAINS-function-exportToJSON-exporters-L81",
      "source": "file-exporters.js-ZXhwb3J0",
      "target": "function-exportToJSON-exporters-L81",
      "type": "CONTAINS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-helpers.js-aGVscGVy",
      "source": "folder-_-Lg==",
      "target": "file-helpers.js-aGVscGVy",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-isPlaceholder-helpers-L25",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-isPlaceholder-helpers-L25",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-generateMeaningfulId-helpers-L29",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-generateMeaningfulId-helpers-L29",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-createNode-helpers-L68",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createNode-helpers-L68",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-generateMeaningfulId-helpers-L29",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-generateMeaningfulId-helpers-L29",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-createRelationship-helpers-L78",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createRelationship-helpers-L78",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-registerContent-helpers-L88",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-registerContent-helpers-L88",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-extractSourceCode-helpers-L105",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-extractSourceCode-helpers-L105",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-getOrCreateFolderNode-helpers-L125",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-getOrCreateFolderNode-helpers-L125",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-createNode-helpers-L68",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createNode-helpers-L68",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-getOrCreateFolderNode-helpers-L125",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-getOrCreateFolderNode-helpers-L125",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-createRelationship-helpers-L78",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createRelationship-helpers-L78",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-registerContent-helpers-L88",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-registerContent-helpers-L88",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-getOrCreateFileNode-helpers-L159",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-getOrCreateFileNode-helpers-L159",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-createNode-helpers-L68",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createNode-helpers-L68",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-getOrCreateFolderNode-helpers-L125",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-getOrCreateFolderNode-helpers-L125",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-createRelationship-helpers-L78",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createRelationship-helpers-L78",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-registerContent-helpers-L88",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-registerContent-helpers-L88",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CONTAINS-function-createEntityNode-helpers-L181",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createEntityNode-helpers-L181",
      "type": "CONTAINS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-extractSourceCode-helpers-L105",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-extractSourceCode-helpers-L105",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-registerContent-helpers-L88",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-registerContent-helpers-L88",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-createNode-helpers-L68",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createNode-helpers-L68",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-getOrCreateFileNode-helpers-L159",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-getOrCreateFileNode-helpers-L159",
      "type": "CALLS"
    },
    {
      "id": "file-helpers.js-aGVscGVy-CALLS-function-createRelationship-helpers-L78",
      "source": "file-helpers.js-aGVscGVy",
      "target": "function-createRelationship-helpers-L78",
      "type": "CALLS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-js_scanner.js-anMtc2Nh",
      "source": "folder-_-Lg==",
      "target": "file-js_scanner.js-anMtc2Nh",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-isPlaceholder-js_scanner-L40",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isPlaceholder-js_scanner-L40",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-isExternalLibrary-js_scanner-L54",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isExternalLibrary-js_scanner-L54",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-generateMeaningfulId-js_scanner-L116",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-generateMeaningfulId-js_scanner-L116",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-createNode-js_scanner-L210",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createNode-js_scanner-L210",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-generateMeaningfulId-js_scanner-L116",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-generateMeaningfulId-js_scanner-L116",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-registerContent-js_scanner-L241",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-registerContent-js_scanner-L241",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-getOrCreateFolderNode-js_scanner-L271",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFolderNode-js_scanner-L271",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createNode-js_scanner-L210",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createNode-js_scanner-L210",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateFolderNode-js_scanner-L271",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFolderNode-js_scanner-L271",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-registerContent-js_scanner-L241",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-registerContent-js_scanner-L241",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-getOrCreateFileNode-js_scanner-L319",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFileNode-js_scanner-L319",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createNode-js_scanner-L210",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createNode-js_scanner-L210",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateFolderNode-js_scanner-L271",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFolderNode-js_scanner-L271",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-registerContent-js_scanner-L241",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-registerContent-js_scanner-L241",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-extractSourceCode-js_scanner-L351",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-extractSourceCode-js_scanner-L351",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-createEntityNode-js_scanner-L383",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createEntityNode-js_scanner-L383",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-extractSourceCode-js_scanner-L351",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-extractSourceCode-js_scanner-L351",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-registerContent-js_scanner-L241",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-registerContent-js_scanner-L241",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createNode-js_scanner-L210",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createNode-js_scanner-L210",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateFileNode-js_scanner-L319",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFileNode-js_scanner-L319",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-analyzeFile-js_scanner-L440",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-analyzeFile-js_scanner-L440",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateFileNode-js_scanner-L319",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFileNode-js_scanner-L319",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-isExternalLibrary-js_scanner-L54",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isExternalLibrary-js_scanner-L54",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createEntityNode-js_scanner-L383",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createEntityNode-js_scanner-L383",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createEntityNode-js_scanner-L383",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createEntityNode-js_scanner-L383",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createEntityNode-js_scanner-L383",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createEntityNode-js_scanner-L383",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createEntityNode-js_scanner-L383",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createEntityNode-js_scanner-L383",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createEntityNode-js_scanner-L383",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createEntityNode-js_scanner-L383",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-isExternalLibrary-js_scanner-L54",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isExternalLibrary-js_scanner-L54",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateExternalLibraryNode-js_scanner-L60",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createRelationship-js_scanner-L227",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createRelationship-js_scanner-L227",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-scanDirectory-js_scanner-L718",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-scanDirectory-js_scanner-L718",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-scanDirectory-js_scanner-L718",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-scanDirectory-js_scanner-L718",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-analyzeFile-js_scanner-L440",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-analyzeFile-js_scanner-L440",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-scanJSService-js_scanner-L744",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-scanJSService-js_scanner-L744",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-createNode-js_scanner-L210",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-createNode-js_scanner-L210",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getOrCreateFolderNode-js_scanner-L271",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getOrCreateFolderNode-js_scanner-L271",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-scanDirectory-js_scanner-L718",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-scanDirectory-js_scanner-L718",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-getContentListsByName-js_scanner-L801",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getContentListsByName-js_scanner-L801",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-exportToNeo4j-js_scanner-L824",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-exportToNeo4j-js_scanner-L824",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-isPlaceholder-js_scanner-L40",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isPlaceholder-js_scanner-L40",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-isPlaceholder-js_scanner-L40",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isPlaceholder-js_scanner-L40",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getContentListsByName-js_scanner-L801",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getContentListsByName-js_scanner-L801",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CONTAINS-function-exportToJSON-js_scanner-L920",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-exportToJSON-js_scanner-L920",
      "type": "CONTAINS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-isPlaceholder-js_scanner-L40",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isPlaceholder-js_scanner-L40",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-isPlaceholder-js_scanner-L40",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-isPlaceholder-js_scanner-L40",
      "type": "CALLS"
    },
    {
      "id": "file-js_scanner.js-anMtc2Nh-CALLS-function-getContentListsByName-js_scanner-L801",
      "source": "file-js_scanner.js-anMtc2Nh",
      "target": "function-getContentListsByName-js_scanner-L801",
      "type": "CALLS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-main.js-bWFpbi5q",
      "source": "folder-_-Lg==",
      "target": "file-main.js-bWFpbi5q",
      "type": "CONTAINS"
    },
    {
      "id": "folder-_-Lg==-CONTAINS-file-scanner.js-c2Nhbm5l",
      "source": "folder-_-Lg==",
      "target": "file-scanner.js-c2Nhbm5l",
      "type": "CONTAINS"
    },
    {
      "id": "file-scanner.js-c2Nhbm5l-CONTAINS-function-scanDirectory-scanner-L14",
      "source": "file-scanner.js-c2Nhbm5l",
      "target": "function-scanDirectory-scanner-L14",
      "type": "CONTAINS"
    },
    {
      "id": "file-scanner.js-c2Nhbm5l-CALLS-function-scanDirectory-scanner-L14",
      "source": "file-scanner.js-c2Nhbm5l",
      "target": "function-scanDirectory-scanner-L14",
      "type": "CALLS"
    },
    {
      "id": "file-scanner.js-c2Nhbm5l-CONTAINS-function-scanJSService-scanner-L30",
      "source": "file-scanner.js-c2Nhbm5l",
      "target": "function-scanJSService-scanner-L30",
      "type": "CONTAINS"
    },
    {
      "id": "file-scanner.js-c2Nhbm5l-CALLS-function-scanDirectory-scanner-L14",
      "source": "file-scanner.js-c2Nhbm5l",
      "target": "function-scanDirectory-scanner-L14",
      "type": "CALLS"
    }
  ],
  "contentRegistrySummary": {
    "folders": 0,
    "files": 0,
    "classes": 0,
    "methods": 0
  }
}